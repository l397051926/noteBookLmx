---- 从头开始，复习一遍
第一章 对象导论
    面向对象设计（OOP）
    1.1 抽象过程
        基于汇编语言的基础，我们产生了多种语言，但是我们的行为都是按照机器来制作的，而并不适用现实的事件，那么我们就需要让现实和机器联合起来，抽象出一些东西，让他们满足一些特性和行为，则就是对象的做法
        smalltalk的五种基本特性
            1. 万物皆为对象
            2. 程序是对象的集合，他们通过发送消息来告知彼此要做的事情
            3. 每个对象都有自己的由其他对象所构成的存储
            4. 每个对象都拥有其类型
            5. 某一特定类型的所有对象都可以接收同样的消息
    1.2 每个对象都有一个接口
    1.3 每个对象都提供服务
    1.4 被隐藏的具体实现
        private proteated public
    1.5 复用具体实现
        每个类可能存在多个类，这些类是通过相互组合的方式实现方法，这些已有的类组合成新的类就是组合的方式，如果是动态的组合 就是聚合的方式，比如汽车拥有发动机
    1.6 继承
        我们拥有一个已有的类，但是不想再这个类上修改，我们可以选择创建一个类，来复制他，然后再这个新类增添内容，就是继承，继承的子类可以覆盖父类的方法，这样使用时就可以使用子类的新方法
        1.6.1 是一个 与 像是一个的关系
            是一个 就是 子类继承父类后，不会在增加多余的方法，只会覆盖父类的方法，保证还都是一类生物
            像是一个 则是 子类继承父类后，在此救赎又增加了自己的独有的方法，这样就是像是一类生物，但是里面是不同的
    1.7 伴随多态的可互换类型
        我们可以用一个父类，比如几何图形，让下面具体的图形继承这个父类，当我们要用几何绘制图形时，可以用父类来调用方法，而当我们使用时，就用具体的实现来构建，也就是在执行时，才知道将用哪个图形绘制，就是多态。
    1.8 单根继承结构
        所有的类都拥有唯一的父类就是Object的类，也是由C传播过来导致的，单根的好处首先是保证了整个类逻辑准群，其次为垃圾回收提供良好的简便性
    1.9 容器
        容器 也就是集合，用于存储一类的对象的集合，java自身就提供了很多容器
        1.9.1 参数化类型
            参数化类型也就是泛型，在java5 之前是没用泛型的，所以统一会传Object 作为容器的对象，但是当具体使用时就涉及到了类型转换，而后期推出了泛型，也就是可以指定一个对象的容器
    1.10 对象的创建和生命期
        我们每当使用一个对象要关心他的创建和销毁，因为对象不可能长时间存在，否则会对内存有很大的压力，那么他什么时候销毁呢，如果放在战中，计算机知道什么时候销毁，但是无法确定他所占用的大小，操作很麻烦，而放在堆中则可以
        不用管他的空间大小，使用多少就可以扩容，但是不知道什么时候不被使用了，java推出了垃圾回收机制， 定期的扫描堆中的对象，如果发现可以回收了，就可以动态的回收
    1.11 异常处理：处理错误
        大部分语言都没法子提供很强的异常容错率，遇到问题都交给开发者来解决异常，java也是，java唯一提供的是在编译时如果语法不规则，编译就不会通过，但是太复杂的时候也不会查出来
    1.12 并发编程
    1.13 java与Internet
        1.13.1 web是什么
        1.13.2 客户端编程
            插件、脚本、java、C#、javaScript...
        1.13.3 服务器端编程

第二章 一切都是对象
    2.1 用引用操作对象
    2.2 必须由你创建所有对象
        使用 new 来创建所有对象
        2.2.1 存储到什么地方
            1. 寄存器 速度很快，但是空间太小了
            2. 堆栈 空间限制无法任意搞
            3. 堆中 空间合适
            4. 常量存储
            5. 非RAM存储
        2.2.2 特例：基本类型
            创建对象都是用new来创建，而基本类型过于小，用new创建太浪费，因此是以值的形式，直接存储在堆中。
            java的基本类型
            --------------------------------------------
            基本类型 大小 最小值 最大值 包装类型
            boolean - - - Boolean
            char 16bit Unicode0 Unicode2^16-1 CharaCter
            byte 8bit -128 127 Byte
            short 16bit -2^15-1 2^15-1 Short
            int 32bit -2^31-1 2^31-1 Integer
            long 64bit -2^63-1 2^63-1 Long
            float 32bit IEEE754 IEEE754 Float
            double 64bit IEEE754 IEEE754 Double
            void - - - Void
            --------------------------------------------
            高精度数据  bigInteger(整数) bigDecimal（浮点数）
        2.2.3 java的数组
    2.3 永远不要销毁对象
        2.3.1 作用域
        2.3.2 对象作用域
    2.4 创建新的数据类型 类 class
        2.4.1 字段和方法
            基本成员的默认值
                类型 默认值
                boolean false
                char '\u0000'
                byte 0
                short 0
                int 0
                long 0L
                float 0.0f
                double 0.0d
    2.5 方法参数和返回值
        2.5.1 参数列表
    2.6 构建一个java程序
        2.6.1 名字可见性
            引入了package 来保证名字的唯一性
        2.6.2 运用其他构建
            import 关键字，导入指定要的包
        2.6.3 static 关键字
            独属于一个空间，可以直接通过类名调用，一个改变全局都改变
    2.7 你的第一个java程序
    2.8 注释和嵌入式文档
        2.8.1 代码注释
        2.8.2 语法
        2.8.3 嵌入式HTML
        2.8.4 一些标签类型
            @see 引用其他类
            @link 引用其他类 展示不同
            @version 版本
            @author 作者
            @since 最早版本
            @param 参数说明
            @return 返回值描述
            @throws 异常
            @deprecated 就特性被新特性取代
    2.9 编码风格
    2.10 总结

第三章 操作符
    3.1 更简单的打印语句
    3.2 使用java操作符
    3.3 优先级
    3.4 赋值语句 =
        把右边的值 赋给 左边
    3.5 算数运算符
        3.5.1 一元 加 和一元 减
    3.6 自动递增和递减
        前缀式 和后缀式， 前缀式就是在表达式或者变量的前面， 后缀式就是变量或表达式的后面
    3.7 关系操作符
        > < >= <= == !=
        3.7.1 测试对象的等价性
    3.8 逻辑操作符
        && || ！
        3.8.1 短路
    3.9 直接常量
        十六进制 前0X
    3.10 换位操作符  & | ！
    3.11 移位操作符 <<  >>
    3.12 三元操作符 if-else  boolean ? x : y
    3.13 字符串 + += 的区别
    3.14 使用操作符 常犯的错误
    3.15 类型转换操作符  cast
        3.15.1 截尾 和舍入
        3.15.2 提升
    3.16 java没有sizeof
    3.17 操作符小结

第四章 控制执行流程
    4.1 true 和false
    4.2 if- else
    4.3 迭代 while (do while) for
        4.3.3 逗号的作用
    4.4 foreach 的写法
    4.5 return
    4.6 break continue
    4.7 臭名昭著的goto
        java 没有实现 goto ，而是用标签的方法来代替这种 跳来跳去的 流程
    4.8 switch case default

第五章 初始化与清理
    5.1 用构造器确保初始化
        构造器是用来初始化类的，当程序调用时，就默认分配了一定的空间给这个对象
        构造器分无惨构造器，有参构造器
        无惨构造器是java所有类默认有的，但是当你指定了构造器，这个就会消失
        构造器的函数名是要和类名保持一致
    5.2 方法的重载
        方法的重载 出生其实是因为构造器不能只有一个，而一个函数的名字是要固定的，那么要想有多个构造器，就需要重载来支撑这个
        5.2.1 区分重载的方法
            每个方法都要有独一无二的参数列表
        5.2.2 涉及基本类型的重载
            要注意 参数的默认转换 比如 short 会自动变成int，传入时就要指定参数类型
        5.2.3 以返回值区分重载方法
    5.3 默认构造器
    5.4 this关键字
        this关键字只能在方法内部使用，表示调用方法那个对象 的引用
        5.4.1 在构造器中调用构造器
            可以通过this 来调用当前对象里的其他构造器
        5.4.2 static的含义
            static中不能调用this，因为不属于一个对象，属于全局的，如果有太多的static，那么这可能就不是面向对象的思想了
        5.5 清理： 中级处理和垃圾回收
            finalize() 方法，不会直接清理的，只是会告诉jvm，当清理的时候 可以清理我这里，更像是一个标记吧
            1. 对象可能不被垃圾回收
            2. 垃圾回收并等于 “析构”
            5.5.1 finalize()的用途何在
                3. 垃圾回收只与内存有关
            5.5.2 你必须实施清理
                意思是如果jvm没有面临内存不够用的时候，是不糊进行垃圾回收清理的，将资源浪费在这个上面
                并且，终结、垃圾回收，都不是一定会去执行的
            5.5.3 终结条件
                当我们用finalize（）方法重新打上标签时，当jvm垃圾回收 或者 system.gc()的时候可能会发现问题进行清理
            5.5.4 垃圾回收器如何工作的
                引用技术法：
                    是一种很简单，但是很慢的垃圾回收技术，每个对象都含有一个引用计数器，当引用增加时 引用就+1,当引用离开时，就置位null
                    但是这种会出现问题，就是如果有循环引用，那么对象可能就无法被回收
                停止-复制 （stop-and-copy）
                    先暂停程序运行，将堆里的对象复制到另一个堆，如果没有复制过去的就说明是垃圾，直接清楚，而复制过去都是紧凑的内存空间，
                    缺点是 要有两个堆，要来回倒腾，
                标记-清楚（mark-and-sweep）
                    适用于少量垃圾甚至不产生垃圾时，这个算法就很快，否则就很慢
                    同样是从堆栈和静态存储区域触发，遍历所有的引用，进而找出存活的对象，打上标记，这个时候不会回收对象，标记完成后，进行清理
                    没有标记的对象会被释放
                自适应技术
                    jvm会根据当前的情况 自动切换回收算法， 自适应的，分代的，停止-复制，标记-清除
                即时（Just-In-Time,JIT）
                    编译器技术，会把所有或者部分类加载到本地机器码中，当使用某个类时，会找到这个.class 将他装在到内存
                    两种方法
                        1. 就是启动时装载所有的类
                        2. 惰性评估，就是需要时才加载
                        新版本JDK Java HotSpot技术采用类似方法，所以执行次数会越来越快
        5.6 成员初始化
            5.6.1 指定初始化
        5.7 构造器初始化
            5.7.1 初始化顺序
                就是类属性拥有默认值，在构造器中会重新对值进行初始化
            5.7.2 静态数据的初始化
                先静态对象，后非静态对象
            5.7.3 显式的静态初始化
                静态代码块的使用
            5.7.4 非静态实例初始化
        5.8 数组的初始化
            int [] al 等价 int al []
            数组创建时，必须指定空间大小或者元素内容
            5.8.1 可变参数列表
                void printArray(Objecs... args)

        5.9 枚举类型
            使用enum 来标记，可以搭配switch语句使用

        5.10 总结

第六章 访问权限控制
    访问控制（或隐藏具体实现） 与 “最初的实现并不恰当” 有关
    public protected 包访问权限（没有关键字） 和private
    6.1 包： 库单元
        package 关键字的使用 ，代表某个域下的类
        6.1.1 代码组织
            使用package 声明包的位置，使用import 导入指定的类
        6.1.2 创建独一无二的包名
            java解释器的过程如下
                首先，找出环境变量CLASSPATH，CLASSPATH包含一个或多个目录，用作查找.class文件的根目录。
                从根目录开始，解释器获取包的名称并将每个句点替换成反斜杠。
                得到的路径会与CLASSPATH中的哥哥不同的链接，
                解释器就在这些目录中查找与你所要创建的类名称相关的.class文件

        6.1.3 定制工具库
        6.1.4 用import改变行为
        6.1.5 对使用包的忠告
    6.2 Java访问权限修饰词
        public， protected， private 这几个Java访问权限修饰词
        6.2.1 包访问权限
            也被称为friendly
        6.2.2 public： 接口访问权限
        6.2.3 private： 你无法访问
        6.2.4 protected：继承访问权限

    6.3 接口和实现
        访问权限的控制常被称为是具体实现的隐藏，把数据和方法包装进类中，以及具体实现的隐藏，常共同被称作为封装。

    6.4 类的访问权限
        1. 每个编译单元 都只能有一个public类
        2. public类的名称必须完全与含有该编译单元的文件名相匹配，包括大小写
        3. 虽然不是很常用，但编译单元内完全不带public类也是可能的

    6.5 总结

第七章 复用类
    复用代码是java众多引人注目的功能之一。但要想成为极具革命性的语言，仅仅能够复制代码并对之加以改变是不够的，它还必须能够做更多的事情









