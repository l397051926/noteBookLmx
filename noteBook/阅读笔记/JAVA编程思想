---- 从头开始，复习一遍
第一章 对象导论
    面向对象设计（OOP）
    1.1 抽象过程
        基于汇编语言的基础，我们产生了多种语言，但是我们的行为都是按照机器来制作的，而并不适用现实的事件，那么我们就需要让现实和机器联合起来，抽象出一些东西，让他们满足一些特性和行为，则就是对象的做法
        smalltalk的五种基本特性
            1. 万物皆为对象
            2. 程序是对象的集合，他们通过发送消息来告知彼此要做的事情
            3. 每个对象都有自己的由其他对象所构成的存储
            4. 每个对象都拥有其类型
            5. 某一特定类型的所有对象都可以接收同样的消息
    1.2 每个对象都有一个接口
    1.3 每个对象都提供服务
    1.4 被隐藏的具体实现
        private proteated public
    1.5 复用具体实现
        每个类可能存在多个类，这些类是通过相互组合的方式实现方法，这些已有的类组合成新的类就是组合的方式，如果是动态的组合 就是聚合的方式，比如汽车拥有发动机
    1.6 继承
        我们拥有一个已有的类，但是不想再这个类上修改，我们可以选择创建一个类，来复制他，然后再这个新类增添内容，就是继承，继承的子类可以覆盖父类的方法，这样使用时就可以使用子类的新方法
        1.6.1 是一个 与 像是一个的关系
            是一个 就是 子类继承父类后，不会在增加多余的方法，只会覆盖父类的方法，保证还都是一类生物
            像是一个 则是 子类继承父类后，在此救赎又增加了自己的独有的方法，这样就是像是一类生物，但是里面是不同的
    1.7 伴随多态的可互换类型
        我们可以用一个父类，比如几何图形，让下面具体的图形继承这个父类，当我们要用几何绘制图形时，可以用父类来调用方法，而当我们使用时，就用具体的实现来构建，也就是在执行时，才知道将用哪个图形绘制，就是多态。
    1.8 单根继承结构
        所有的类都拥有唯一的父类就是Object的类，也是由C传播过来导致的，单根的好处首先是保证了整个类逻辑准群，其次为垃圾回收提供良好的简便性
    1.9 容器
        容器 也就是集合，用于存储一类的对象的集合，java自身就提供了很多容器
        1.9.1 参数化类型
            参数化类型也就是泛型，在java5 之前是没用泛型的，所以统一会传Object 作为容器的对象，但是当具体使用时就涉及到了类型转换，而后期推出了泛型，也就是可以指定一个对象的容器
    1.10 对象的创建和生命期
        我们每当使用一个对象要关心他的创建和销毁，因为对象不可能长时间存在，否则会对内存有很大的压力，那么他什么时候销毁呢，如果放在战中，计算机知道什么时候销毁，但是无法确定他所占用的大小，操作很麻烦，而放在堆中则可以
        不用管他的空间大小，使用多少就可以扩容，但是不知道什么时候不被使用了，java推出了垃圾回收机制， 定期的扫描堆中的对象，如果发现可以回收了，就可以动态的回收
    1.11 异常处理：处理错误
        大部分语言都没法子提供很强的异常容错率，遇到问题都交给开发者来解决异常，java也是，java唯一提供的是在编译时如果语法不规则，编译就不会通过，但是太复杂的时候也不会查出来
    1.12 并发编程
    1.13 java与Internet
        1.13.1 web是什么
        1.13.2 客户端编程
            插件、脚本、java、C#、javaScript...
        1.13.3 服务器端编程

第二章 一切都是对象
    2.1 用引用操作对象
    2.2 必须由你创建所有对象
        使用 new 来创建所有对象
        2.2.1 存储到什么地方
            1. 寄存器 速度很快，但是空间太小了
            2. 堆栈 空间限制无法任意搞
            3. 堆中 空间合适
            4. 常量存储
            5. 非RAM存储
        2.2.2 特例：基本类型
            创建对象都是用new来创建，而基本类型过于小，用new创建太浪费，因此是以值的形式，直接存储在堆中。
            java的基本类型
            --------------------------------------------
            基本类型 大小 最小值 最大值 包装类型
            boolean - - - Boolean
            char 16bit Unicode0 Unicode2^16-1 CharaCter
            byte 8bit -128 127 Byte
            short 16bit -2^15-1 2^15-1 Short
            int 32bit -2^31-1 2^31-1 Integer
            long 64bit -2^63-1 2^63-1 Long
            float 32bit IEEE754 IEEE754 Float
            double 64bit IEEE754 IEEE754 Double
            void - - - Void
            --------------------------------------------
            高精度数据  bigInteger(整数) bigDecimal（浮点数）
        2.2.3 java的数组
    2.3 永远不要销毁对象
        2.3.1 作用域
        2.3.2 对象作用域
    2.4 创建新的数据类型 类 class
        2.4.1 字段和方法
            基本成员的默认值
                类型 默认值
                boolean false
                char '\u0000'
                byte 0
                short 0
                int 0
                long 0L
                float 0.0f
                double 0.0d
    2.5 方法参数和返回值
        2.5.1 参数列表
    2.6 构建一个java程序
        2.6.1 名字可见性
            引入了package 来保证名字的唯一性
        2.6.2 运用其他构建
            import 关键字，导入指定要的包
        2.6.3 static 关键字
            独属于一个空间，可以直接通过类名调用，一个改变全局都改变
    2.7 你的第一个java程序
    2.8 注释和嵌入式文档
        2.8.1 代码注释
        2.8.2 语法
        2.8.3 嵌入式HTML
        2.8.4 一些标签类型
            @see 引用其他类
            @link 引用其他类 展示不同
            @version 版本
            @author 作者
            @since 最早版本
            @param 参数说明
            @return 返回值描述
            @throws 异常
            @deprecated 就特性被新特性取代
    2.9 编码风格
    2.10 总结

第三章 操作符
    3.1 更简单的打印语句
    3.2 使用java操作符
    3.3 优先级
    3.4 赋值语句 =
        把右边的值 赋给 左边
    3.5 算数运算符
        3.5.1 一元 加 和一元 减
    3.6 自动递增和递减
        前缀式 和后缀式， 前缀式就是在表达式或者变量的前面， 后缀式就是变量或表达式的后面
    3.7 关系操作符
        > < >= <= == !=
        3.7.1 测试对象的等价性
    3.8 逻辑操作符
        && || ！
        3.8.1 短路
    3.9 直接常量
        十六进制 前0X
    3.10 换位操作符  & | ！
    3.11 移位操作符 <<  >>
    3.12 三元操作符 if-else  boolean ? x : y
    3.13 字符串 + += 的区别
    3.14 使用操作符 常犯的错误
    3.15 类型转换操作符  cast
        3.15.1 截尾 和舍入
        3.15.2 提升
    3.16 java没有sizeof
    3.17 操作符小结

第四章 控制执行流程
    4.1 true 和false
    4.2 if- else
    4.3 迭代 while (do while) for
        4.3.3 逗号的作用
    4.4 foreach 的写法
    4.5 return
    4.6 break continue
    4.7 臭名昭著的goto
        java 没有实现 goto ，而是用标签的方法来代替这种 跳来跳去的 流程
    4.8 switch case default

第五章 初始化与清理
    5.1 用构造器确保初始化
        构造器是用来初始化类的，当程序调用时，就默认分配了一定的空间给这个对象
        构造器分无惨构造器，有参构造器
        无惨构造器是java所有类默认有的，但是当你指定了构造器，这个就会消失
        构造器的函数名是要和类名保持一致
    5.2 方法的重载
        方法的重载 出生其实是因为构造器不能只有一个，而一个函数的名字是要固定的，那么要想有多个构造器，就需要重载来支撑这个
        5.2.1 区分重载的方法
            每个方法都要有独一无二的参数列表
        5.2.2 涉及基本类型的重载
            要注意 参数的默认转换 比如 short 会自动变成int，传入时就要指定参数类型
        5.2.3 以返回值区分重载方法
    5.3 默认构造器
    5.4 this关键字
        this关键字只能在方法内部使用，表示调用方法那个对象 的引用
        5.4.1 在构造器中调用构造器
            可以通过this 来调用当前对象里的其他构造器
        5.4.2 static的含义
            static中不能调用this，因为不属于一个对象，属于全局的，如果有太多的static，那么这可能就不是面向对象的思想了
        5.5 清理： 中级处理和垃圾回收
            finalize() 方法，不会直接清理的，只是会告诉jvm，当清理的时候 可以清理我这里，更像是一个标记吧
            1. 对象可能不被垃圾回收
            2. 垃圾回收并等于 “析构”
            5.5.1 finalize()的用途何在
                3. 垃圾回收只与内存有关
            5.5.2 你必须实施清理
                意思是如果jvm没有面临内存不够用的时候，是不糊进行垃圾回收清理的，将资源浪费在这个上面
                并且，终结、垃圾回收，都不是一定会去执行的
            5.5.3 终结条件
                当我们用finalize（）方法重新打上标签时，当jvm垃圾回收 或者 system.gc()的时候可能会发现问题进行清理
            5.5.4 垃圾回收器如何工作的
                引用技术法：
                    是一种很简单，但是很慢的垃圾回收技术，每个对象都含有一个引用计数器，当引用增加时 引用就+1,当引用离开时，就置位null
                    但是这种会出现问题，就是如果有循环引用，那么对象可能就无法被回收
                停止-复制 （stop-and-copy）
                    先暂停程序运行，将堆里的对象复制到另一个堆，如果没有复制过去的就说明是垃圾，直接清楚，而复制过去都是紧凑的内存空间，
                    缺点是 要有两个堆，要来回倒腾，
                标记-清楚（mark-and-sweep）
                    适用于少量垃圾甚至不产生垃圾时，这个算法就很快，否则就很慢
                    同样是从堆栈和静态存储区域触发，遍历所有的引用，进而找出存活的对象，打上标记，这个时候不会回收对象，标记完成后，进行清理
                    没有标记的对象会被释放
                自适应技术
                    jvm会根据当前的情况 自动切换回收算法， 自适应的，分代的，停止-复制，标记-清除
                即时（Just-In-Time,JIT）
                    编译器技术，会把所有或者部分类加载到本地机器码中，当使用某个类时，会找到这个.class 将他装在到内存
                    两种方法
                        1. 就是启动时装载所有的类
                        2. 惰性评估，就是需要时才加载
                        新版本JDK Java HotSpot技术采用类似方法，所以执行次数会越来越快
        5.6 成员初始化
            5.6.1 指定初始化
        5.7 构造器初始化
            5.7.1 初始化顺序
                就是类属性拥有默认值，在构造器中会重新对值进行初始化
            5.7.2 静态数据的初始化
                先静态对象，后非静态对象
            5.7.3 显式的静态初始化
                静态代码块的使用
            5.7.4 非静态实例初始化
        5.8 数组的初始化
            int [] al 等价 int al []
            数组创建时，必须指定空间大小或者元素内容
            5.8.1 可变参数列表
                void printArray(Objecs... args)

        5.9 枚举类型
            使用enum 来标记，可以搭配switch语句使用

        5.10 总结

第六章 访问权限控制
    访问控制（或隐藏具体实现） 与 “最初的实现并不恰当” 有关
    public protected 包访问权限（没有关键字） 和private
    6.1 包： 库单元
        package 关键字的使用 ，代表某个域下的类
        6.1.1 代码组织
            使用package 声明包的位置，使用import 导入指定的类
        6.1.2 创建独一无二的包名
            java解释器的过程如下
                首先，找出环境变量CLASSPATH，CLASSPATH包含一个或多个目录，用作查找.class文件的根目录。
                从根目录开始，解释器获取包的名称并将每个句点替换成反斜杠。
                得到的路径会与CLASSPATH中的哥哥不同的链接，
                解释器就在这些目录中查找与你所要创建的类名称相关的.class文件

        6.1.3 定制工具库
        6.1.4 用import改变行为
        6.1.5 对使用包的忠告
    6.2 Java访问权限修饰词
        public， protected， private 这几个Java访问权限修饰词
        6.2.1 包访问权限
            也被称为friendly
        6.2.2 public： 接口访问权限
        6.2.3 private： 你无法访问
        6.2.4 protected：继承访问权限

    6.3 接口和实现
        访问权限的控制常被称为是具体实现的隐藏，把数据和方法包装进类中，以及具体实现的隐藏，常共同被称作为封装。

    6.4 类的访问权限
        1. 每个编译单元 都只能有一个public类
        2. public类的名称必须完全与含有该编译单元的文件名相匹配，包括大小写
        3. 虽然不是很常用，但编译单元内完全不带public类也是可能的

    6.5 总结

第七章 复用类
    复用代码是java众多引人注目的功能之一。但要想成为极具革命性的语言，仅仅能够复制代码并对之加以改变是不够的，它还必须能够做更多的事情
    7.1 组合语法
    7.2 继承语法
        关键字 extends
        关键字 super 表示超类
        子类在构造时，父类也会同时被构造了，构建过程是向外扩散的
    7.3 代理
        就是A类有很多动作，而B类要用A类的动作，将A类对象放入B类中，将B类对外暴露，由B类调用A类里的方法，使用B类代理A类使用，实际功能是A累的功能
    7.4 结合使用组合和继承
        7.4.1 确保正确清理
            使用try +finally 来处理数据一定被清洗和执行
        7.4.2 名称屏蔽
            利用@Override 来重写超类里面的方法
    7.5 在组合与继承之间选择
        判定 两个对象是 is-a 的关系还是 has-a 的关系，来选择使用继承还是组合
    7.6 protected 关键字
        只允许子类可以访问的 关键字，但是对于其外部来说还是private的
    7.7 向上转型
        用父类声明，用子类实现，代表向上转型
        有哪些方法是看声明类，而具体实现则是看实现类
        7.7.1 为什么称为向上转型
            因为是用超类来声明，将子类往超类上转换，所以是向上转型
        7.7.2 再轮组合和继承
            对于OOP 来说，我们应该使用继承，但是继承的关系不能乱用，我们参考的方法就是，是否真的需要向父类转换，如果是，那就一定要使用继承
    7.8 final 关键字
        这是无法改变的含义的关键字，可以使用三种地方 数据 方法 和类
        7.8.1 final 数据
            1. 一个永不改变的编译时常量
            2. 一个运行时被初始化的值，而你不希望它被改变
            空白final 必须要保证初始化时给他值
        7.8.2 final方法
            使用final的方法，无法被子类进行重写 覆盖
            private 和final ，private已经暗示这个方法为final了
        7.8.3 final 类
            当将某个类的整体定义final，就不允许再有类继承他，从设计上看，这个类不需要任何变动，从安全考虑，这个类不需要在被继承
        7.8.4 有关final的忠告
    7.9 初始化及类的加载
        7.9.1 继承与初始化
            当一个基类被初始化时，首先找他的父类，就算没有明确继承也会找隐士的父类，然后会初始化父类，如果父类还有父类，会递归的向上初始化
            直到所有的都被初始化完成
    7.10 总结
        继承和综合都是交互使用，在恰当的使用可以让我们代码更有健壮性

第八章 多态
    在面向对象的程序设计语言中，多态是继数据抽象和继承之后的第三种基本特征
    动态绑定，后期绑定或运行时绑定

    8.1 再论向上转型
        8.1.1 忘记对象类型
    8.2 转机
        8.2.1 方法调用绑定
            将一个方法调用同一个方法主体关联起来被称为绑定。若在程序执行前进行绑定（如果有的话，由编译器和链接程序实现）叫做前期绑定
            后期绑定：在运行时根据对象的类型进行绑定，后期绑定也叫运行时绑定或动态绑定
            java 除了 static final private 方法 都可以做后期绑定
        8.2.2 产生正确的行为
        8.2.3 可扩展性
            多态是让程序员 将改变的事物与未来的事物分离开来
        8.2.4 缺陷：“覆盖” 私有方法
            子类中是不会覆盖 超类的private方法，就算子类定义了一样的方法，就算名字相同，其实也是新的方法 独属于子类的方法
        8.2.5 缺陷： 域与静态方法
            静态的方法也不符合多态的规则
    8.3 构造器和多态
        构造器不同于其他种类的方法，构造器本质是静态的方法，只是不需要声明 static
        8.3.1 构造器的调用顺序
        8.3.2 继承与清理
        8.3.3 构造器内部的多态方法和行为
            准则： 用尽可能简单的方法使对象进入正常的状态；如果可以的话，避免调用其他方法。在构造器内唯一能够安全调用的那些2方法是基类中的final方法。
            这些方法不能被覆盖，因此也就不会出现问题
    8.4 协变返回类型
        表示在导出类中的呗覆盖方法可以返回基类方法的返回类型的某种导出类型
    8.5 用继承进行设计
        准则：用继承表达行为间的差异，并用字段表达状态上的变化
        8.5.1 纯继承与扩展
            纯粹 的 is-a 的关系 就很适合用继承
            而 is -like -a 像一个关系 子类扩展出其他的方法，如果用向上转型 就无法使用基类新的方法
        8.5.2 向下转型与运行时类型识别
            如果向下转型失败 会抛出异常ClassCaseException
    8.6 总结
        多态意味着 不同的形式。在面向对象的程序设计中，我们持有从基类继承而来的相同接口，以及使用该接口的不同形式，不同版本的动态绑定方法

第九章 接口
    接口和内部类为我们提供了一种将接口与实现分离的更加结构化的方法
    9.1 抽象类和抽象方法
        abstract void f(); 抽象方法， 只有声明，没有实现
        包含这种方法的类 叫做抽象类  absttract class
    9.2 接口
        interface关键字 定义接口
        一个接口表示： 所有实现了该特定接口的类看起来都像这样
        类要实现接口 需要使用关键字 implemens
        接口里的方法都是public 默认如此
    9.3 完全解耦
    9.4 java中的多重继承
        接口可以使用 多重继承，就好比一个类实现多个接口，就要实现多个接口里的方法
    9.5 通过继承来扩展接口
        通过继承，可以很容易地在接口中添加新的方法声明，还可以通过继承在新接口中组合数个接口。这两种情况都可以获得新的接口
        9.5.1 组合接口时的名字冲突
            要注意这种情况
    9.6 适配接口
    9.7 接口中的域
        接口里的函数和常量都是 static final 形式的 可以用他来定义常量
        9.7.1 初始化接口中的域
    9.8 嵌套接口
        在类中 嵌套接口 在类中在实现它，感觉使用并不高，只是一种支持写法
    9.9 接口与工厂
        接口尝尝用来实现工厂模式
    9.10 总结
        确定接口是理想乡选择，因而应该总是选择接口而不是具体的类

第十章 内部类
    可以将一个类的定义放在另一个类的定义内部，这就是内部类
    10.1 创建内部类
        普通内部类， 静态内部类， 匿名内部类 局部内部类
    10.2 链接到外部类
        将内部类的对象作为一个引用发到外部类中
    10.3 使用.this与.new
    10.4 内部类与向上转型
    10.5 在方法和作用域内的内部类
        要解决一个复杂的问题，又不希望外部可以访问这些类的定义，可以使用内部类来组合使用
    10.6 匿名内部类
        匿名内部类没有构造器
        10.6.1 在访工厂方法
            使用内部类实现工厂类
    10.7 嵌套类
        如果不需要内部类对象与其外围类对象之间有联系，那么可以将内部类声明为static。这通常为嵌套类
        10.7.1 接口内部的类
            可以用内部类 来写测试接口 就很隔离
        10.7.2 从多层嵌套类中访问外部类的成员
            内部类中可以调外部类的属性 尽管他是private的
    10.8 为什么需要内部类
        每个内部类都能独立地继承自一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响。
        内部类可以有多个实例，每个实例都有自己的状态信息，并且与其外围类对象的信息相互独立
        在单个外围类中，可以让多个内部类以不同的方式实现同一个接口，或继承同一个类
        创建内部类对象的时刻并不依赖于外围类对对象的创建。
        内部类并没有令人迷惑的is-a关系，它就是一个独立的实体
        10.8.1 闭包与回调
            闭包（closure）是一个可调用的对象，它记录了一些信息，这些信息来自于创建它的作用域，通过这个定义，可以看出内部类是面向对象的闭包，因为它不仅包含外围类对象的信息，还自动拥有一个指向此外围类对象的引用，在此作用域内，内部类有权操作所有的成员，包括private程璇
        10.8.2 内部类与控制框架
            多个控制框架（control framework）
            用用程序框架（application framework） 模板设计模式
            事件驱动系统  经典例子：图形用户接口GUI
    10.9 内部类的继承
        内部类的构造方法会相对复杂化，必须使用sper这种方式才可以通过
    10.10 内部类可以被覆盖么
        当继承了某个外围类的时候，内部类没有发生神奇的变化，这两个内部类是完全独立的实体，各自在自己的命名空间内
    10.11 局部内部类
        在方法里创建内部类，就属于局部内部类
        为什么要用局部内部类而不用匿名内部类呢？唯一的理由是 我们需要一个已命名的构造器，或者需要重载构造器
    10.12 内部类的标识符
        每个类编译后都会有 名字.class 文件 而内部类则是 名字$内部类.class 这种表示
    10.13 总结

第十一章 持有对象
    如果一个程序只包含固定数量的且其生命期都是已知的对象，那么这是一个非常简单的程序
    利用java的容器来持有对象，这一章主要讲java常见的容器内容
    11.1 泛型和类型安全的容器
        @SuppressWaringings 不受检查的异常
        ArrayList 默认存的对象是Object 如果不指定泛型，那么在get的时候 就会发送ClassCaseEExcetpion 类型转换的异常
        所以在使用容器时最好指定他存储的容器类型
    11.2 基本概念
        java的容器类库拥有两个不同的概念
        1. Collection 保存一组元素序列 list是 顺序保存元素 set 是不能有重复元素 queue 排队规则确定对象顺序
        2. Map 保存 key-vale 键值对的数据 也被称为字典 可以使用键来查找数据
    11.3 添加一组元素
        常用的工具方法 Arrays Collections
        使用 Collections.addAll()  Arrays.asList()
    11.4 容器的打印
        常见容器
        ArrayList ,LinkedList, HashSet, TreeSet, LinkedHashSet, HashMap, TreeMap, LinkedHashMap
        ArrayList,LinkedList 都是按照插入顺序保存元素，区别只是他们操作类型的性能上的区别
        HashSet LinkedHashSet TreeSet 都是保存一份数据，HaseSet 插入和提取都很快， LinkedHashSet 是保证插入顺序 TreeSet 则是比较 值 来排序保存数据默认升序
        HashMap 提供了快速查找数据 ，TreemAP 则保证类排序顺序 linkedHashMap 则按照插入顺序保存 同时保留了HashMap的查询速度
    11.5 List
        ArrayList 善于随机访问元素，但是中间插入和移除元素会很慢
        LinkedList 上虞插入和删除操作，提供了优化的顺序访问，随机访问则相对比较慢
        subList 截取中间的一部分 retainAll 交集操作， removenAll 移除部分元素 通过equals 判定， addAll 则是添加元素 可以是中间也可以是尾部
        isEmpty 是否为空 clear 清空容器 toArray 则是转换成数组
    11.6 迭代器
        迭代器是一种设计模式，它的工作是遍历并选择序列中的对象，而客户端不必知道或关系该序列的底层结构
        此外迭代器通常被称为轻量级对象， 创建它代价小
        比如java 的 Iterator 只能单向移动，
        1. 使用方法iterator()要求容器返回一个Iterator，Iterator将准备好返回序列第一个元素
        2. 使用next()获得序列中的下一个元素
        3. 使用hasNext() 检查序列中是否还有元素
        4. 使用remove()将迭代器新进返回的元素删除

        11.6.1 ListIterator
            是一个更加强大的Iterator的子类型，支持双向移动，可以使用set()方法替换它访问过的最后一个元素
            可以使用 ListIterator() 产生一个指向List开始处的ListIterator，也可以使用ListIterator方法创建一个指向列表索引为n的元素
    11.7 LinkedList
        执行在List中间插入和移除 要比ArrayList更高效，但是在随机访问上却要逊色一些
        LinkeList 还添加了可以使其用作 栈，队列 ，双端队列的方法
        getFirst() element() 如果List为空 则抛出异常NoSuchElementException peek 则会返回null
        removeFirst() remove() 同样数据为空 跑异常 而 poll() 则返回null
        addFirst add() addLast() 相同
        removeLast() 移除并返回列表的最后一个元素

    11.8 Stack
        栈 后进先出(LIFO) 容器，也被称为叠加栈， 最后一个压入的数据会第一个弹出，LinkList满足栈的特性，所以可以当做栈使用
        push 压栈 peek 战顶数据 pop 出站 isEmpty 是否为空
        可以使用 net.mindivew.util.Stack

    11.9 Set
        不保存重复的元素，通过一定的判定条件，为了看set 里面是否重复，set拥有 hashset 快速查找元素的功能
        HashSet使用了三列，TrreeSet存储使用了红-黑树，保证了值的排序， LinkeHashList，使用了链表维护了元素的插入顺序
    11.10 Map
        根据 key-value 来存储的数据 每个key 不可以相同
        keySet() 可以获取所有的key 的set 集合

    11.11 Queue
        队列 先进先出 （FIFO） LinkList 天然支持 队列功能
        offer() 方法将一个元素插入对尾
        peek() element() 都是不移除队首元素 展示对首数据 一个抛异常 一个返回null
        poll() remove() 都是移除并且展示队首数据 一个抛异常 一个返回 null

        11.11.1 PriorityQueue
            优先级队列，声明下一个弹出的元素是最优先级的数据
            offer() 插入数据会进行排序

    11.12 Collection 和 Iterator
        Collection 是所有序列容器的共性跟接口
        Iterator 是Collection 的父接口 用于迭代器的使用

    11.13 Foreach与迭代器
        foreach语法主要用于数组
        iterator() 返回了Iterator<String> 的实例，可以使用 foreach语句中
        大部分类都是Iterable类型
        而数组不可以当成Iterable参数传递

        11.13.1 适配器方法惯用法

    11.14 总结

第十二章 通过异常处理错误
    java 的基本理念： 结构不佳的代码不能运行
    12.1 概念
    12.2 基本异常
        异常情形(exceptional condition) 当异常出现时 程序停止 向外部抛出一个异常
        程序会寻找一个恰当地方来继续执行程序，这个恰当的地方就是 异常处理程序
        12.2.1 异常参数
            出现异常时，我们回在堆上 new 异常对象
            所有标准异常会有两个构造器，一个是默认构造器 ，一个是接受字符串作为参数，把相关信息放入到异常中
            关键字 throw
    12.3 捕获异常
        首先要拥有 监控区域(guarded region)，它是一段可能产生异常的代码，并且后面跟着处理这些异常的代码
        12.3.1 try块
            try {} 监控区域
        12.3.2 异常处理程序
            catch (Type type) {} 处理程序
            终止和恢复
            当异常出现时 ，一般两种解决方案，如果这个异常已经导致后续的程序无法处理，则终止这个程序，如果这个异常后续还可以处理，可以使用
            while(){try{}} 这种方式 ，来忽略这次异常 恢复的执行任务
    12.4 创建自定义异常
        可以定义一个类 继承Exception 来构造自己的异常
        12.4.1 异常与记录日志
            使用Logger 来控制出现的异常输出
    12.5 异常说明
        使用 throws 来标志这个会出现什么异常，让使用者进行处理
    12.6 捕获所有异常
        可以使用捕获 Exception 来捕获所有异常
        12.6.1 栈轨迹
            printStackTrace()
        12.6.2 重新抛出异常
            在 catch 在throw 出异常
            使用 fillInstackTrace() 变成了异常的新发生地
        12.6.3 异常连
            常常会想要在捕获一个异常后抛出另一个异常，并且希望把原始异常信息保存下来，这就是异常链
            Throwable是 异常顶级父类， 下面有三种异常，Error（java虚拟机报告系统错误）
            Excetpion  RuntimeException
            可以使用initCause() 方法而不是构造器 异常链接起来
    12.7 java 标准异常
        Throwable这个java 类被 用来表示任何可以作为异常被抛出的类
        Error 用来表示编译时和系统错误
        Exception 是可以被抛出基本类型
        12.7.1 特例 RuntimeException
            只能在代码中忽略RuntimeException（及其子类）类型的异常，其他类型异常的处理都是由编译器强制实时的，原因是 RuntimeException代表的是编程错误
            1. 无法预料的错误，比如你控制方为之外传递进来的null 引用
            2. 作为程序员，应该在代码中进行检查的错误
    12.8 使用finally 进行清理
        对于一些代码，可能会希望无论try 中的异常是否被抛出，都要执行这部分代码，就可以放入finally中执行
        12.8.1 finally用来做什么
            用来关掉 已经打开的文件或网络连接，屏幕上画的图形，甚至外部世界的某个开关
        12.8.2 在return中使用finally
            有return finally也会返回
        12.8.3 缺憾： 异常丢失
            异常作为程序出错的标志，决不应该被忽略，但它还是有可能被轻易的忽略，用特殊方式使用finally子句
    12.9 异常的限制
        当覆盖方法的时候，只能抛出基类方法的异常
    12.10 构造器
        在构造对象时抛出异常
    12.11 异常匹配
        抛出异常的时候，异常处理系统会按照代码的书写顺序找出“最近”的处理程序。找到匹配的处理程序之后，它就认为异常将得到处理，然后就不再继续查找了
        查找的时候并不要抛出的异常同处理程序所声明的异常完全匹配。派生类的对象也可以匹配其基类的处理程序。
    12.12 其他可选方式
        异常处理系统就像一个活门（trap door）,就是代表主程序无法正常执行，通过活门进入指定工作内容
        12.12.1 历史
        12.12.2 观点
        12.12.3 把异常传递给控制台
        12.12.4 把 被检查的异常 转换为 不检查异常
    12.13 异常使用指南
        应该在下列情况下使用异常；
        1. 在恰当的级别处理问题（在知道该如何处理的情况下才捕获异常）
        2. 解决问题并且重新调用产生异常的方法
        3. 进行少许修补，然后绕过异常发生的地方继续执行。
        4. 用别的数据进行计算，以代替方法预计会返回的值
        5. 把当前运行环境下能做的事情尽量做完，然后把相同的异常重抛到更高层
        6. 把当前运行环境下能做的事情尽量做完，然后把不同的异常抛到更高层。
        7. 终止程序。
        8. 进行简化（如果你的 异常模式问题变得太复杂，那用起来会非常痛苦也很烦人）
        9. 让类库和程序更安全（这既是在为调试做短期投资，也是在为程序的健壮性做长期投资）
    12.14 总结

第十三章 字符串
    可以证明， 字符串操作是计算机程序设计中最常见的行为。
    13.1 不可变String
        final 修饰，每次获取的都是新的String
    13.2 重载 + 与StringBuilder
        String 对象是不可变的，你可以给一个String 对象加任意多的别名。因为String对象具有只读特性，所以他的任何引用都不可能改变他的值
        编译器会帮你优化一部分 String 的拼接性能
    13.3 无意识的递归
        toString() 方法，会打印出对象的信息，如果想打印地址，可以使用this 这个方式
    13.4 String上的操作
        方法      参数，重载版本     应用
        构造器     重载笨笨，默认版本   创建String对象
        length()                    String中字符的个数
        charAt()    Int索引          取得String中该索引位置上的char
        getChars(),getBytes 要复制部分的起点和重点的索引，复制的目标数组，目标数组的起始索引    复制char或byte到一个目标数组中
        toCharArray()                   生成一个char[],包含String的所有字符
        equals(),equalsIgnoreCase() 与之进行比较的String   比较两个String的内容是否相同
        compareTo() 与之进行比较的String   按词典顺序比较String的内容，比较结果为负数，零或正数。注意，大小写并不等价
        contains()  要搜索的CharSequence    如果该String对象包含参数的内容，则返回true
        contentEquals() 与之进行比较的CharSequence或StringBuffer    如果该String与参数的内容完全一致，则返回true
        equalsIgnoreCase()  与之进行比较的String   忽略大小写，如果两个String的内容相同，则返回true
        reglonMatcher()     该String的索引偏移量，另一个String及其索引偏移量，要比较的长度。重载版本增加了忽略大小写功能    返回boolean结果，以表名所比较区域是否相等
        startsWith()        可能的起始String。重载版本在参数中增加了偏移量      返回boolean结果，以表名改String是否以参数起始
        endsWith()          该String可能的后缀String      返回boolean，以表名此参数是否该字符串的后缀
        indexOf(),lastIndexOf()     重载版本包括：char，char与起始索引，String，String与起始索引        如果该String并不包含此参数，就返回-1，否则返回此参数在String中的起始索引，lastIndexOf（）是从后向前搜索
        substring()(subSequence())  重载版本，起始索引，起始索引+重点坐标     返回一个新的string，以包含参数指定的子字符串
        concat()        要链接的String      返回一个新的String对象，内容为原始String链接上参数String
        replace()       要替换掉的字符串，用来进行替换的新字符     返回替换字符后的新String对象，如果没有替换发生，则返回原始的String对象
        toLowerCase() toUpperCase()                 将字符的大小写改变后，返回一个新String对象。如果没有改变发生，则返回原始的String对象
        trim()                                      将String连贯的空白字符删除后，返回一个新的String对象。如果没有改变发生，则返回原始的String对象
        valueOf()       从在版本        返回一个表示参数内容的String
        intern()                        为每个唯一的字符序列生成一个且仅生成一个String引用
    13.5 格式化输出
        13.5.1 printf()
            printf("Row 1: [%d %f]", x, y)
        13.5.2 System.out.format()
        13.5.3 Formatter类
        13.5.4 格式化说明符
        13.5.5 Formatter转换
            d 整数（十进制）
            c Unicode字符
            b boolea值
            s String
            f 浮点数（十进制）
            e 浮点数（科学技术）
            x 整数（十六进制）
            h 散列码（十六进制）
            % 字符"%"
        13.5.6 String.format()
    13.6 正则表达式
        13.6.1 基础
        13.6.2 创建正则表达式
            Pattern 正则表达式类
            . 任意字符 [abc] 包含abc任意字符 [^abc]除了abc之前的任意字符 [a-zA-Z]范围从a到z或者从A到Z
            [abc[hij]] 任意a b c hi j 字符
            [a-z&&[h(j)]] 任意h i 或 j   \s 空白符  \S 非空白符 \d 数字 \D 非数字 \w词字符 \W 非词字符
            ^ 一行开的起始    $ 一行的结束  \b 词的边界  \B非词的边界  \G前一个匹配的结束
        13.6.3 量词
            贪婪型： 量词总是贪婪的，除非有其他的选项被设置。贪婪表达式会为所有可能的模式发现尽可能多的匹配。
            勉强性： 用问号来指定，这个量词匹配满足模式所需的最少字符数，因此也称作懒惰的，最少匹配的
            占有行： 目前，这种类型的量词只有java语言中才可用
        13.6.4 Pattern和Matcher
            用 static Pattern.comlile()方法边界表达式
            用 matcher()方法 返回Matcher对象
            macthcer 拥有 group的概念
            Pattern 标记
        13.6.5 split()
        13.6.6 替换操作
        13.6.7 reset
            通过reset()方法，可以将现有的Matcher对象应用于一个新的字符序列
        13.6.8 正则表达式与Java I/O
    13.7 扫描输入
        Scanner的构造器接受任何类型的输入对象
        13.7.1 Scanner定界符
            默认是用空白字符对输入进行分词，可以使用正则表达式来分词
        13.7.2 用正则表达式扫描
    13.8 string Tokenizer
    13.9 总结

第十四章 类型信息
    运行时类型信息使得你可以在程序运行时发现和使用类型信息
    java是如何让我们在运行时识别对象和类的信息，主要两种方式，一种是传统的RTTI，它嘉定我们在编译时知道了所有类型
    另一种是反射机制，它允许我们在运行时发现和使用类的信息
    14.1 为什么需要RTTI （Run-Time Type Identification）
        使用RTTI，可以查询某个类引用所只想的对象的确切类型，然后进一步进行操作
    14.2 class 对象
        class 对象就是用来创建类的所有的常规对象，java使用class对象来执行其RTTI，即使你正在执行的是类似转型这样的操作。class类还拥有大量的使用RTTI的其他方式
        jvm 会根据当前的情况 利用类加载器，将指定的类加载jvm的内存中，如果这个类在就获得class的类对象，如果没加载进来，则会查找.class的文件，进行验证，然后加载到内存中
        使用 Class.forName("com.dd...Student") 查找类名的类
        getSimpleName() getCanonicalName()
        printInfo()  getName()
        getInterfaces() 返回Classd对象
        getSuperclass() 直接基类
        14.2.1 类字面常量
            java还提供了另一种方法来生成对Class对象的引用，即使用磊子面常量 莱斯 List.class
            注意： 当时用.class 来创建对class对象的引用时，不会自动地初始化该class对象。为了使用类而做的准备工作实际包含三个步骤
            1. 加载 类加载器执行
            2. 链接 在链接阶段验证类中的字节码， 为静态域分配存储空间，如果可以，会创建对其他类的所有引用
            3. 初始化。 如果该类是超类，则对齐初始化，执行青苔初始化器和静态初始化快
        14.2.2 泛化的class引用
            class 引用总是指向某个class对象
            使用泛型来构建 class，可以使用通配符 来详细指定class的类型 通配符?
            Class<?> intClass = int.class
            intClass = double.class
            cast 可以转换具体的类型

    14.3 类型转换前先做检查
        我们已知的RTTI形式包括
        1. 传统的类型转换
        2. 代表对象的类型的class对象
        使用 instanceof 判定类型是否是对应类型
        instancof 有严格的限制， 只可将其与命名类型进行比较，而不能与class对象作为比较
        14.3.1 使用类字面常量
        14.3.2 动态的instanceof
            Class.isInstance()
        14.3.3 递归计数
            isAssignableFrom() 运行时检查，校验传递的对象是否属于我们的继承结构
    14.4 注册工厂
    14.5 instanceof 与class的等价性
        instanceof 保持了类型的概念，而用== 比较实际的对象，没有考虑继承，只考虑是否是这个类型
    14.6 反射：运行时的类信息
        14.6.1 类方法提取器
            反射支持其他特性，例如序列化和JavaBean,
            使用方法
            Class<?> c = Class.forName();
            c.getMehods(); c.getConstructors()
    14.7 动态代理
        代理是基本的设计模式之一，它是你为了提供额外的或不同的操作，而插入的用来代替实际对象，这些操作通常设计实际对象的通信，因此代理通常充当着中间人的角色
        通过 Proxy.newProxyInstance()
        invoke() 方法传递代理对象和参数，进行代理执行
        更多代理方式可以 看我的代理详解篇章
    14.8 空对象
        可以当做临时赋值，交给变量，防止编译报错
        14.8.1 模拟对象与桩
            空对象的逻辑变体是模拟对象和桩。与空对象一样，它们都表示在最终的程序中所使用的“实际”对象，但是，模拟对象和桩都只是假扮可以传递实际信息的存活对象，而不是像空对象那样可以称为null的一种更加智能化的替代物
    14.9 接口与类型信息
        interface关键字的一种重要目标就是允许程序员隔离构件，进而降低耦合性。如果你编写接口，那么久可以实现这一目标，但是通过类型信息，这种耦合性还是会传播出去---接口并非是对解耦的一种无懈可击的保障
    14.10 总结

第十五章 泛型
    一般的类和方法，只能使用具体的类型：要么是基本类型，要么是自定义的类，如果要编写可以用多种类型的代码，这种刻板的限制对代码的束缚就会很大
    15.1 与C++的比较
    15.2 简单泛型
        许多原因需要有泛型，而使用最高的就是 容器类
        核心概念：告诉编译器想使用什么类型，然后编译器帮你处理一切细节
        15.2.1 一个元祖类库
        15.2.2 一个堆栈类
            末端哨兵 用来标志是否容器为空
        15.2.3 RandomList
    15.3 泛型接口
        泛型可以应用于接口。例如 生成器（generator），这是一种专门负责创建对象的类
    15.4 泛型方法
        public <T>void getT(T t)
        使用泛型方法时，不需要指明参数类型，编译器为什么找出具体类型，称为类型参数的推断(type argument inference)
        15.4.1 杠杆利用类型参数推断
            显示的类型说明
            在泛型方法中，可以显式滴指明类型
        15.4.2 可变参数与泛型方法
        15.4.3 用于Generator的泛型方法
        15.4.4 一个通用的Generator
        15.4.5 简化元祖的使用
        15.4.6 一个Set实用工具
    15.5 匿名内部类
    15.6 构造复杂的模型
    15.7 擦除的神秘之处
        在泛型代码内部，无法获得任何有关泛型参数类型的信息
        java泛型是使用擦除来实现的，这意味着当你在使用泛型，任何具体的类型信息都被擦出了，你唯一知道的就是你在使用一个对象。因此List<String>和List<Integer>在运行时
            事实上是相同的类型。这两种形式都被擦除成他们的 原生类型，即List
        15.7.1 C++ 方式
            使用 extends Object 方式来定位擦除 就可以安全的调用 f() 方法
            我们说泛型类型参数将擦除到它的第一个边界，我们还提到了类型参数的擦除。编译器实际上会把类型参数替换为它的擦除
        15.7.2 迁移兼容性
        15.7.3 擦除的问题
            泛型不能用于显式地引用运行时类型的操作中，例如转型 instanceof操作和new的表达式
        15.7.4 边界处的动作
    15.8 擦除的补偿
        15.8.1 创建类型实例
            使用工厂类来构建 无法new T() 的问题
        15.8.2 泛型数组
            T[]
    15.9 边界
        上边界 是用 extends Object
        下边界 ? super MyClass
    15.10 通配符
        ? extends Fruit 具有任何从Fruit继承的类型列表
        T extends A & B 一种写法 并不是很了解
        15.10.1 编译器有多聪明
        15.10.2 逆变
            超类通配符 ? super MyClass
        15.10.3 无解通配符
            <?> 任何事物
        15.10.4 捕获转换
    15.11 问题
        15.11.1 任何基本类型都不能作为类型参数
            可以使用包装类 来替代 基本类型
            但是，自动包装机制不能应用于数组，因此这无法工作
        15.11.2 实现参数化接口
            一个类不能实现同一个泛型接口的两种变体，由于擦除的原因，这两个变体会成为相同的接口。
        15.11.3 转型和警告
            使用带有泛型类型参数的转型或instanceof不会有任何效果
        15.11.4 重载
            由于擦除的原因，重载方法将产生相同的类型签名
            由此不同的是，当被擦除的参数不能产生唯一的参数列表时，必须提供明显有区别的方法名
        15.11.5 基类劫持了接口
    15.12 自限定的类型
        class SelfBounded<T extends SelfBounded<T>>{//
        这种很难解析的写法
        15.12.1 古怪的循环泛型
        15.12.2 自限定
            BasicHolder可以使用任何类型作为其泛型参数
            自限定所作的，就是要求在继承关系中，像下面这样使用这个类
            class A extends SelfBounded<A>{}
            自限定限制只能强制作用域继承关系！
        15.12.3 参数协变
            自限定类型的价值在于它们可以产生协变参数类型--- 方法参数类型会随子类而变化。
    15.13 动态类型安全
        java.util.Collections中有一组便利工具，解决类型检查问题，它们是checkedCollection(),checkedList(),checkedMap(),checkedSet(),checkedSortedMap()和checkedSortedSet()
    15.14 异常
        由于擦除的原因，将泛型应用于异常是非常受限的。catch语句不能捕获泛型的异常，因为在编译器和运行时都必须知道异常的确切类型。泛型类也不能直接活间接继承自Throwable
    15.15 混型
        术语混型随时间的推移好像拥有了无数的含义，但是其最基本的概念是混合多个类的能力，以产生一个可以表示混型中所有类型的类。这往往是你最后的手段，它将使组装多个类变得简单易行
        混型的价值之一是它们可以将特性和行为一致地应用于多个类上。如果想在混型类中修改某些东西，作为一种意外的好处，这些修改将会应用于混型所应用的所有类型之上。正由于此，混型有一点面向方面编程AOP的味道，而方面经常被建议用来解决混型问题
        15.15.1 C++中的混型
        15.15.2 与接口混合
        15.15.3 使用装饰器模式
            装饰器模式使用分层对象来动态透明地向单个对象中添加责任。
        15.15.4 与动态代理混合
    15.16 潜在类型机制
        鸭子类型机制：它走起来像鸭子，并且叫起来也像鸭子，那么你就可以将它当做鸭子对待
    15.17 对缺乏潜在类型机制的补偿
        java 不支持潜在类型机制，可以用一些别的方式来补偿这些
        15.17.1 反射
        15.17.2 将一个方法应用于序列
        15.17.3 当你并未碰巧拥有正确的接口时
        15.17.4 用适配器仿真潜在类型机制
    15.18 将函数对象用作策略
        策略设计模式，这种设计模式可以产生更优雅的代码，因为它将 变化的事物 完全隔离到了一个函数对象中
    15.19 总结 转型真的如此之槽么

第十六章 数组
    16.1 数组为什么特殊
        数组与其他种类的容器之间之间的区别三方面：效率，类型和保存基本类型的能力
    16.2 数组是第一级对象
        无论使用哪种类型的数组，数组标识符其实只是一个引用，只想在堆中创建的一个真实对象，这个对象用以保存指向其他对象的引用。
    16.3 返回一个数组
        String[] rand = {"aa","b"}
    16.4 多维数组
        int[][] a = {{1,2,3},{4,5,6}}
    16.5 数组与泛型
    16.6 创建测试数据
        16.6.1 Arrays.fill() 填充
        16.6.2 数据生成器
        16.6.3 从Generatory 中创建数组
    16.7 Arrays实用功能
        equals() 判断两个数组是否相等
        deepEquals 用于多位数组
        fill() 填充
        sort 排序
        binarySearch 用于已经排序的数组查找元素
        toString() 产生数组的String表示
        hashCode 散列码
        asList 撰文List容器
        16.7.1 复制数组
            System.arraycopy() 需要的参数 原数组 ，开始复制的偏移量 目标数组偏移量 复制元素的个数
        16.7.2 数组的比较 equals
        16.7.3 数组元素的比较
            使用Comparable.compareTo 方法进行比较
            构建单独的类 实现 Comparator接口 重写 compare方法 和equals 方法 后面不是必须
        16.7.4 数组的排序
            java内置的算法为 快速排序  ，以及针对对象设计的稳定归并排序
        16.7.5 在已排序的数组中查找 Arrays.binarySearch()
    16.8 总结

第十七章 容器深入研究
    17.1 完整的容器分类法
        看图 <JAVA编程思想_容器高级分类>
        java se5 增加了
        Queue 接口 以及实现PriorityQueue和各种风格的Blockingueue
        ConcurrentMap 实现了ConcurrentHashMap，他们也是用于多线程机制
        CopyOnWriteArrayList和CopyOnWriteArraySet，他们也是用于多线程机制的
        EnumSet和EnumMap，为使enum而设计的Set和Map的特殊实现，
        在Collections类中的多个便利方法
    17.2 填充容器
        可以使用Collections fill() 方法
        17.2.1 一种Generator解决方案
            LinkedHashSet 维护了插入顺序的链接列表
        17.2.2 Map生成器
        17.2.3 使用Abstract类
            享元模式，使得对象的一部分可以被具体化
    17.3 Collection的功能方法
        boolean add(T)
        确保容器持有具有泛型类型T的参数，如果没有将此参数添加进容器，则返回false
        boolean addAll(Collection<? extends T>)
        添加参数中的所有元素。只添加了任意元素就返回true
        vold clear()
        移除容器中所有元素
        boolean contains(T)
        如果容器已经持有具有泛型类型T此参数，则返回true
        boolean containsAll(Collection<?>)
        如果容器持有此参数中的所有元素，则返回true
        boolean isEmpty()
        容器中没有元素时返回true
        Iterator<T> iterator()
        返回一个Iterator<T>, 可以用来便利容器中的元素
        Boolean remove<Object>
        如果参数在容器中，则移除此元素的一个实例，如果做了移除动作，则返回true
        boolean removeAll(Collection<?>)
        移除参数中的所有元素。只有移除动作发生就返回true(可选的)
        Boolean retainAll(Collection<?>)
        只保存参数中的元素（交集的概念），只要Collection发生了改变就返回true
        int size()
        返回容器中元素的数目
        Object[] toArray()
        返回一个数组，该数组包含容器中的所有元素
        <T> T[] toArray(T[] a)
        返回一个数组，该数组包含容器中的所有元素。返回结果的运行时类型与参数数组a的类型相同，而不是单纯的Object
    17.4 可选操作
       17.4.1 未获支持的操作 UnsupportedOperationException
            Arrays.asList() 出来的list 就无法在添加元素了
    17.5 List的功能方法
        add, addAll,contains,containsAll,get,indexOf,isEmpty,iterator,listIterator,lastIndexOf,retainAll,removeAll
        set,
        ArrayList, LinkedList
    17.6 Set存储顺序
        Set
        存入Set的每个元素都必须是唯一的，因为Set不保存重复元素，加入Set的元素必须定义equals()方法以确保对象的唯一性。Set与Collection有安全一样的接口。
        Set接口不保证维护元素的次序
        HashSet
            为快速查找而设计的Set。存入HashSet的元素必须定义HashCode()
        TreeSet
            保持次序的Set，底层为树结构。使用它可以从Set中提取有序的序列。元素必须实现Comparable接口
            TreeSet<Integer> treeSet = new TreeSet<>((o1, o2) -> o1 - o2);
        LinkedHashSet
            具有HashSet的查询速度，且内部使用链表维护元素的顺序（插入的次序）。于是在使用迭代器便利Set时，结果会按照元素插入的次序现实，元素也必须定义HashCode方法
        17.6.1 SortedSet
            first，last, subSet(fromElement,ToElement), headSet(toElement),tailSet(fromElement)
    17.7 队列
        LinkedList,PriorityQueue
        17.7.1 优先级队列
            需要实现Comparable来进行控制
        17.7.2 双向队列
            LinkedList 实现了双向队列的功能
            addFirst addLast,getFirst,getLast,removeFirst,removeLast,size,toString
    17.8 理解Map
        HashMap, TreeMap, LinkedHashMap, WeekHashMap, ConcurrentHashMap, IdentityHashMap
        17.8.1 性能
            性能是映射表中的一个重要问题，get()线性搜索时，执行速度会相当地慢，而正式HashMapt提高速度的地方，使用了特殊的值，散列码，来取代对键的缓慢搜索
            HashMap 是是使用了对象的hashCode() 进行快速查询，显著提高了性能
            HashMap
            Map基于散列表实现，插入和查询“键值对”的开销是固定的，可以通过构造器设置容量和负载因子，以调整容器的性能
            LinkedHashMap
            类似于HashMap，但是迭代遍历时，取得 键值对 的顺序是插入的次序，或者是最近最少使用LRU的次序，只比HashMap慢一点，而在迭代访问时，方为更快，因为它使用链表维护内部次序
            TreeMap
            基于红黑树实现。查看键 或键值对时，它们会被排序，TreeMap的忒点在于，所得到的的结果是警告排序的。TreeMap是唯一带有subMap方法的map，它可以返回一个子树
            WeekHashMap
            弱键 映射，允许释放映射所指向的对象；这是为解决某类特殊问题而设计的。如果映射之外没有引用指向某个键，则此键可以被垃圾收集器回收
            ConcurrentHashMap
            一种线程安全的Map，它不涉及同步加锁
            IdentityHashMap
            使用 == 代替equals()对 键进行比较的三列映射。专为解决特殊问题而设计的
        17.8.2 SortedMap
            要实现 Comparator ，null 表示自然排序， subMap(fromKey, toKey)生成子集，headMap(toKey) 小于TOKey的所有键， tailMap(fromKey) 大雨fromKey的子集
        17.8.3 LinkedHashMap
            LinkedHashMap三列化了所有元素，但是遍历的时候，又以1插入顺序返回键值对，可以在构造器中设定LinkedHashMap 采用基于访问的最招使用LRU算法，
    17.9 三列与散列码
        正确的equals 必须满足5个条件
        1. 自反性。对任意x，x.equals(x)一定返回true
        2. 对称性 对任意 x,y x.equals(y) 与 y.equals(x) 结果要一致
        3. 传递性，对任意x,y,z, 如果有 x.equals(y) 返回true y.equals(z) 范湖true ，则 x.equals(z)一定返回ture
        4. 一致性，对任意x和y，如果对象中用于等价比较的信息没有改变，那么无论调用x.equalse 结果应该保持一致
        5. 对任意不是null的x x.equals() 返回一定false
        17.9.1 理解hashCode()
        17.9.2 为速度而散列
            散列的价值在于速度：散列使得查询得以快速进行。由于瓶颈位于键的查询速度，因此解决方案之一就是保持键的排序状态，然后使用Collections.binarySearch()进行查询
            通过散列直接确定数组对应位置，如果散列好的话，可以保证数组每个位置的list 的大小特别小，因此使得查询速度很快
            散列表的槽位 通常称为桶位，
        17.9.3 覆盖hashCode()
            1.给int变量result赋予某个非零值常量
            2. 为对象内每个有意义的域f 计算出一个int散列码c
            3. 合并计算得到的散列码
            4. 返回result
            5. 检查hashCode()最后生成的结果，确保相同的对象有相同的散列码
    17.10 选择接口的不同实现
        17.10.1 性能测试框架
        17.10.2 对List的选择
            Vector避免使用，因为职位了兼容之前的代码，首选应该是ArrayList，如果因为大量插入和删除导致的性能问题，可以使用LinkeList，如果是固定的集合，
            可以使用Arrays.asList(),也可以使用数组，而CopyOnWriteArrayList是List的一个特殊实现，专门用作并发实现
        17.10.3 微基准测试的危险
        17.10.4 对Set选择
            有效选择TreeSet,HashSet,LinkedHashSet
            HashSet的基本性能都比TreeSet好，特别是添加和查询上，TreeSet存在的原因就是因为可以维持元素的排序状态,
            LinkedHashSet比HashSet代价更高；这是维护链表导致的额外开销
        17.10.5 对Map的选择
            Hashtable性能和HashMap相当，因为HashMap是用来替代Hashtable的
            TreeMap要比HashMap要慢，如果需要有序的map可以使用他
            当然如果需要使用的话 默认最好还是HashMap，只有当需要排序时，在将HashMap专程TreeMap，除非你需要时时保证顺序
            LinkedHashMap要比HashMap慢一点，因为它维护散列数据结构的同事还要维护链表，保证插入顺序
            IdentityHashMap具有完全不同的性能，因为它使用==而不是equals来比较元素
            HashMap的性能因子
            容量：表中的桶位数
            初始容量： 表在创建时所拥有的的桶位数，
            尺寸： 表中当前存储的项数
            负载因子：表示当福仔情况达到福仔因子水平时，会增加容量桶的为数，负载轻表示冲突的可能性小，因此对插入和查找都是最理想的
                容器扩容后悔重新将现有对象分步到新的桶位几种（再散列）
            HashMap 默认负载因子0.75
            如果知道HashMap的容量，那么初始容量将可以避免自动再散列的开销
    17.11 实用方法
        Collections拥有许多静态方法
        checkedCollection, checkedList, checkedMap, checkedSet, checkedSortedMap,checkedSorteSet
        产生Collection或者Collection的具体子类型的动态类型安全的视图。在不可能实用静态检查版本时实用这些方法
        max() min()
        返回参数Collection中最大或最小的元素，采用Collection内置的自然比较方法
        max(colection,comparator),min(colection,comparator)
        返回参数Collectionz中最大或最小的元素，采用Comparator进行比较
        indexOfSubList(source, target)
        返回target在source中第一次出现的位置，或者找不到返回-1
        lastIndexOfSubList(source, target)
        返回target在source中最后一次出现的位置，或者找不到返回-1
        replaceAll(List ,oldVal, newVal)
        实用 newVal替换所有的oldVal
        reverse(List)
        逆转里边的元素
        reverseOrder()
        返回一个Compartor,它可以逆转实现了Comparator的对象集合的自然顺序，第二个版本可以逆转所提供的Comparator的顺序
        rotate(list, int distance)
        所有元素向后移动distance个位置，将末尾的元素循环到前面来
        shuffle(List) shuffle(List, Random)
        随机改变指定列表的顺序，第一种提供了自己的最忌机制，第二种可以使用自己的随机机制
        sort(List),sort(List,Comparator)
        使用list中的自然顺序排序，第二种可以自己指定排序规则
        copy(List dest, List src)
        将stc中的元素复制到dest中
        swap(list, int i ,int j)
        交换list中位置i与位置j的元素
        fill（list,T x）
        用对象 x替换list中所有元素
        nCopies(int n,T x)
        返回大小为n的List,此List不可改变，其中的引用都指向x
        disjoint(Collection, Collection)
        当两个集合没有任何相同元素时，返回true
        frequency(Collection,Object x)
        返回Collection中等于x的元素个数
        emptyList(),emptyMap(),emptySet()
        返回不可变的空List,Map或Set,这些方法都是泛型的，因此所产生的结果将被参数化为所希望的类型
        singletom(T x),singletonList(T x),singletonMap(K key,V value)
        产生不可变的Set,List,Map 它们都只包含基于所给定参数的内容而形成的单一项
        list
        产生一个ArrayList,它包含的元素顺序，与返回这些元素的顺序相同，用来转换遗留老代码
        enumeration
        为参数生成一个旧试的Enumeration
        17.11.1 List的排序和查询
        17.11.3 Collection或Map的同步控制
            Collections.synchronizedMap， synchronizedList, synchronizedSet, synchronizedSortedMap
            快速报错
            当你使用迭代器时，向容器插入时 就报错了，因为破坏了容器
            ConcurrentHashMap,CopyOnWrieArrayList,CopyOnWriteArraySet都可以避免这个问题
    17.12 持有引用
        抽象类 Reference
        SoftReference,WeakReference,PhantomReference
        SoftReference 用于实现内存敏感的高速缓存
        Weakreference 是为实现“规范映射” 而设计的，它不方案垃圾回收器回收映射的键 或者 值规范映射中对象的实例可以在程序的多处被同时使用
        Phantomreference 用以调度回收前的清理工作，它比java终止机制更灵活
        ReferenceQueue 总是生成一个包含null对象的Reference
        17.12.1 WeakHashMap
            它被用来保存WeakReference,
    17.13 Java 1.0/1.1
        17.13.1 Vector和Enumeration
        17.13.2 Hashtable
        17.13.3 Stack
        17.13.4 BitSet
            如果要高效率地存储大量“开、关”信息，BitSet是很好的选择。不过它的效率仅是对空间而言，如果需要搞笑的访问时间，BitSet比本地数组稍慢了一点

    17.14 总结

第十八章 Java i/o系统
    对程序语言的设计者来说，创建一个号的输入/输出 系统是一项吉安娜的任务

    18.1 File类
        处理文件或文件集的工具类
        18.1.1 目录列表器
            使用 File 以及 FilenameFilter
        18.1.2 目录实用工具
        18.1.3 目录的检查及创建
            f.getAbsolutePath(), f.canRead(), f.canWrite(), f.getName(), f.getParent(), f.getPath(), f.length()
            f.lastModified(), f.isFile(), f.isDirectory(), f.exists(), f.mkdirs(), f.delete()

    18.2 输入和输出
        18.2.1 InputStream
            InputStream的作用是永红来表示那些从不同数据源产生输入的类，包括
            1. 字节数组
            2. String对象
            3. 文件。
            4. 管道，工作方式与实际管道像是，即 从一段输入，从另一端输出
            5. 一个由其他种类的流组成的序列，以便我们可以将它们手机合并到一个流内
            6. 其他数据源，如Internet链接等
            InputStream 常见类型
            1. ByteArrayInputStream
                允许将内存的缓冲区当做InputStream
                缓冲区，字节将从中取出作为一种数据源：将其与FilterInputStream对象项链以提供有用接口
            2. StringBufferInputStream
                将String转换成InputStream
                字符串。底层实现实际使用StringBUffer作为一种数据源：将其与FillterInputStream对象项链以提供游泳接口
            3. FileInputStream
                用于从文件中读取信息
                字符串，表示文件名，文件或FileDescriptor对象， 作为一种数据源：将其与FilterInputStream对象项链以提供游泳接口
            4. PipedInputStream
                产生用于写入相关PipedOutputSteam的数据。实现管道化的概念
                PipedOutputStream 作为多线程中的数据源：将其与FilterInputStream对象项链以提供游泳接口
            5. SequenceInputStream
                将两个或多个InputStream对象转换成单一InputStream
                两个InputStream对象或一个容纳InputStream对象的容器Enumeration，作为一种数据源：将其与FilterInputStream对象相连以提供有用接口
            6. FilterInputStream
                抽象类，作为“装饰器”的接口。其中“装饰器”为其他的InputStream类提供有用功能
        18.2.2 OutputStream
            1. ByteArrayOutputStream
                在内存中创建缓冲区。所有送往“流”的数据都要防止在缓冲区
                缓冲区初始化尺寸（可选的）用于指定数据的目的地：将其与Filter-OutputStream对象相连以提供游泳接口
            2. FileOutputStream
                用于将信息写至文件
                字符串，表示文件名，文件或FileDescriptor对象， 指定数据的目的地，将其与FilterOutputStream对象相连以提供游泳接口
            3. PipedOutputStream
                任何写入其中的信息都会自动作为相关PipedInputStream的输出。实现“管道化”概念
                PipedInputStream 指定用于多线程的数据的目的地：将其与FilterOutputStream对象相连以提供有用接口
            4. FilterOutputStream
                抽象类，作为装饰器的接口
    18.3 添加属性和有用的接口
        FilterInputStrem和FilterOutputStream是用来提供装饰器类接口以控制特定输入流和输出流的两个类，他们的名字并不是很直观。FilterInputStream和FilterOutputStream分别自I/O类库中的基类InputStream和OutputStream派生而来，这两个类是装饰器的必要条件
        18.3.1 通过FilterInputStream从InputStream读取数据
            FilterInputStream类型
            1. DatainputStream
                与DataOutputSteram搭配使用，因此我们可以按照可移植方式从流读取基本数据类型
                InputStream 包含用于读取基本类型数据的全部接口
            2. BufferedInputStream
                使用它可以防止每次读取时都得进行实际写操作。代表"使用缓冲区"
                InputStream，可以指定缓冲区大小（可选的） 本质上不提供接口，只不过是向进程中添加缓存区所必须的。与接口对象搭配
            3. LineNumberInputStream
                跟中输入流中的行号；可调用getLineNumber()和SetLineNumber(int)
                InputStream 仅增加了行号，因此可能要与接口对象搭配使用
            4. PushbackInputStream
                具有“能弹出一个字节的缓冲区”。因此可以将督导的最后一个字符回退
                InputStream 通常作为编译器的扫描器，之所以包含在内是因为java编译器的需要，我们可能永远不会用到
        18.3.2 通过FilterOutPutStream向OutputStream写入
            FilterOutputStream类型
            1. DataOutputStream
                与DataInputStream搭配使用，因此可以按照可移植方式向流中写入基本类型数据
                OutputStream 包含用于写入基本类型数据的全部接口
            2. PrintStream
                用于产生格式化输出。其中DataOutputStream处理数据的存储，PrintStream处理显示
                OutputStream,可以用boolean值指示是否在每次换行时清空缓冲区应该是对OutputStream对象的final封装。可能会经常使用到它
            3. BufferedOutputStream
                使用它以避免每次发送数据时都要进行实际的写操作。代表"使用缓冲区"。可以调用flush()清空缓冲区
                OutputStream,可以指定缓冲区大小， 本质上并不提供接口，只不过是向进程中添加缓冲区所必须的。与接口对象搭配
    18.4 Reader和Writer
        Reader和Writer则提供兼容Unicode与面向字符的I/0功能
        RW和IO的区别 主要是新旧上和对国际上的支持 IO 主要是支持8字接的，而Unicode是16字节的，因此RW的诞生也是如此
        18.4.1 数据的来源和去处
            如果可以，尽量是使用RW 来进行操作文件，如果实在不行比如zip等文件则使用IO 来处理
            RW和IO两者的对应关系
            InputStream / InputStreamReader
            OutputStream / OutputStreamWriter
            FileInputStream / FileReader
            FileOutputStream / FileWriter
            StringBufferInputStream(已弃用) / StringReader
            （无相应的类） / StringWriter
            ByteArrayInputStream / CharArrayReader
            ByteArrayOutputStream / CharArrayWriter
            PipedInputStream / PipedReader
            PipedOutputStream / PipedWriter
        18.4.2 更改流的行为
            对于IO 我们回使用FilterInputStream和FilterOutputStream来装饰器修饰对应Reader和Writer层次结构也是相似的
            FilterInputStream / FilterReader
            FilterOutputStream / FilterWriter
            BufferedInputStream / BufferedReader
            BufferedOutputStream / BufferedWriter
            DataInputStream / DataInputStream 畜类使用使用readLine()，应该用BufferedReader
            PrintStream / PrintWriter
            LineNumberInputStream(已弃用) / LineNumberReader
            StreamToenizer / StreamTokenizer
            PushbackInputStream / PushbackReader
        18.4.3 未发生变化的类
            DataOutputStream File RandomAccessFile SequenceInputStream
    18.5 自我独立的类： RandomAccessFile
        这个类使用与由大小已知的记录组成的文件，所以我们可以使用seek()将记录从一处转义到另一处
        在1.4时候 RandomAccessFile的大多数功能被nio存储映射文件所取代
    18.6 I/O流的常用使用方式
        18.6.1 缓冲输入文件
        18.6.2 从内存中输入
        18.6.3 格式化的内存输入
            使用DataInputStream
        18.6.4 基本的文件输出
            使用PrintWriter 添加辅助构造器 对文本文件输出的快捷方式
        18.6.5 存储和恢复数据
            使用DataOutputStream写入数据，使用DataInputStream恢复数据
        18.6.6 读写随机访问文件
        18.6.7 管道流 PipeInputStream,PipedOutputStream,PipedReader及PipedWriter
    18.7 文件读写的实用工具
        18.7.1 读取二进制文件
    18.8 标准IO
        标准IO的意义在于：我们可以很容易滴把程序串联起来，一个程序的标准输出可以称为另一个程序的标准输入。
        18.8.1 从标准输入中读取
        18.8.2 将System.out换换成PrintWriter
        18.8.3 标准I/O重定向
    18.9 进程控制
    18.10 新I/O
        速度提高来自于所使用的结构更接近于操作系统执行I/O的方式：通道和缓冲器
        18.10.1 转换数据
            java.nio.CharBuffer
        18.10.2 获取基本类型
            asCharBuffer(), asShortBuffer()
        18.10.3 视图缓冲器
            可以让我们通过某个特定的基本数据类型的视图查看其底层的ByteBuffer
            字节存放次序
        18.10.4 用缓冲器操纵数据
        18.10.5 缓冲器的细节
            Buffer由数据和可以搞笑滴访问及操作这些数据的四个索引组成，这四个索引是：mark(标记),position(位置),limit(界限),capacity(容量)
            1. capacity()
                返回缓冲区容量
            2. clear()
                清空缓冲区，将position设置为0，limit设置为容量。我们可以调用此方法覆写缓冲区
            3. flip()
               将limit设置为position, position设置为0，此方法用于准备从缓冲区读取已经写入的数据
            4. limit
                返回limit值
            5. limit(int lim)
                设置limit值
            6. mark()
                将mark设置为position
            7. position(int pos)
                设置position值
            8. position
                返回position值
            9. remalning()
                返回(limit -position)
            10. hasRemaining()
                若有结余position和limit之间的元素，则返回true
            【看图】
        18.10.6 内存映射文件
            性能
        18.10.7 文件加锁
            FileLock() 或 lock() 可以对整个文件进行加锁
            映射文件的部分加锁
            可能需要对这种巨大的文件进行部分加锁，以便其他进程可以修改危急中未被加锁的部分，数据库就是这种设计
            线程类 LockAndModify 创建了缓冲区和用于修改的slice()
    18.11 压缩
        可以使用InputStreamReader和OutputStreamWriter两种类型转换
        压缩类
        1. CheckedInputStream
            GetCheckSum()为任何InputStream产生校验和
        2. CheckedOutputStream
            GetCheckSum() 为任何OutputStream产生校验和
        3. DeflaterOutputStream
            压缩类的基类
        4. ZipOutpuStream
            用于将数据压缩成Zip文件格式
        5. GZIPOutgputStream
            用于将数据压缩成GZIP文件格式
        6. InflaterInputStream
            解压缩的基类
        7. ZipInputStream
            用于解压缩Zip文件格式的数据
        8. GZIPInputStream
            用于解压缩GZIP文件格式的数据
        18.11.1 用GZIP进行简单压缩
            new BufferedReader(new FileReader(path))
            new BufferedOOutputStream(new GZIPOutgputStream(new FileOutputStream(test.gz)))
            new BufferedReader(new InputStreamReader(new GZIPInputStream(new FileInputStream(test.gz))))
        18.11.2 用Zip进行多文件保存
            Adler32 它快一些， CRC32 慢一些，但更准确
            csum =  new CheckedOutputStream(f, new Adler32())
            new ZipOutputStream(csum)
            ....
        18.11.3 java档案文件
    18.12 对象序列化
        序列化的意义 1. 用于将对象持久化的保存你起来，不因程序挂掉而消失，2.用于远程方法调用
        18.12.1 寻找类
        18.12.2 序列化的控制
            transient 关键字
            当我们虚序列化进行控制时，可能某个特定子对象不想让Java的序列化机制自动保存与恢复，它的意思是 不用麻烦你保存或恢复数据--我自己会处理
            版本控制
            支持度并不好
        18.12.3 使用 “永久性”
    18.13 XML
    18.14 Preferences
        Preferences 与对象序列化相比，前者与对象持久性更密切，因为它可以自动存储和读取信息
        Prefereneces 是一个键-值集合，存储在一个节点层次结构中
    18.15 总结

第十九章 枚举类型
    关键字可以将一组具名的值的有限集合创建为一种新的类型，而这些具名的值可以作为常规的程序组件使用。这是一种非常游泳的功能
    19.1 基本enum特性
        使用 values() 方法，可以遍历enum实例
        19.1.1 将静态导入用于enum
    19.2 向enum中添加新方法
        19.2.1 覆盖enum的方法
    19.3 switch语句中的enum
    19.4 values()的神秘之处
    19.5 实现，而非继承
        所有的enum都继承自java.lang.Enum类。由于javabuild支持多重继承，所以你的enum不能再继续继承其他类
    19.6 随机选取
        Enums.random(.class)
    19.7 使用接口组织枚举
        可以通过接口里面定义enum 子类
        可以使用枚举的枚举 这种方法
    19.8 适应EnumsSet替代标志
        EnumsSet 是一个非常高效的枚举集合
        EnumSet<Enum> points = Enumset.noneOf(Enum.class)
    19.9 使用EnumMap
        是一种特殊的Map ，key必须来自一个enum，
        EnumMap<Enmu,Command> em = new EnumMap<>(Enum.class)
    19.10 常量相关方法
        19.10.1 使用enum的职责链
        在职责链设计模式中，程序员以多种不同的方式来解决一个问题，然后将它们链接在一起。当一个请求到来时，它遍历这个连，知道链表中的某个解决方案能够处理该请求
    19.11 多路分发
        配置多路分发需要很多的供血，记住，它的好处在于方法调用时的优雅的语法，避免了在一个方法中评多个对象的类型的丑陋代码
        19.11.1 使用enum分发
        19.11.2 使用常量相关的方法
        19.11.3 使用EnumMap分发
        19.11.4 使用二维数组

第二十章 注解
    注释（也被称为元数据）为我们在代码中添加信息提供了一种形式化的方法，使我们可以在稍后某个时刻非常方便地使用这些数据
    20.1 基本语法
        20.1.1 定义注释
        @Target(ElementType.METHOD)
        @rETENTION(RetenionPliicy.RuTIME)
        public @interface Test{}
        元注解 @Target 定义你的注解将应用于什么地方
        @Rectetion 定义该注解在哪一个级别可用 源码中（SOURCE） 类文件中(CLASS) 运行时（RUNTIME）
        没有元素的注解 叫做标记注解
        20.1.2 元注解
            1.Target
                CONSTRUCTOR:构造器的声明
                FIELD:域声明
                LOCAL_VARIABLE:局部变量声明
                METHOD：方法声明
                PACKAGE：包声明
                PARAMETER：参数声明
                TYPE：类，接口或enmu声明
            2. Retention
                表示需要在什么级别保存该注解信息。可选的RetentionPolicy参数包括
                SOURCE:注解将被编译器丢掉
                CLASS：注解在class文件中可用，但会被VM丢弃
                RUNTIME：VM将在运行期也保留注解，因此可以通过反射机制读取注解的信息。
            3. Documented
                此注解包含在Javadoc中
            4. Inherited
                允许子类继承父类中的注解
    20.2 编写注解处理器
        20.2.1 注解元素
        20.2.2 默认值限制
            使用default 来进行配置
        20.2.3 生成外部文件
        20.2.4 注解不支持继承
        20.2.5 实现处理器
    20.3 使用apt处理注解
        注解处理工具apt，这是sun为了帮助注解的处理过程而提供的工具。由于这是该工具第一版，功能比较基础
    20.4 将观察者模式用于apt
    20.5 基于注解的单元测试
        20.5.1 将@Unit用于泛型
        20.5.2 不需要任何“套件”
        20.5.3 实现@Unit
        20.5.4 移除测试代码
    20.6 总结

第二十一章 并发
    21.1 并发的多面性
        使用并发时需要解决的问题有多个，而实现并发的方式也有多种，并且在这两者之间没有明显的映射关系
        实现并发最直接的方式在操作系统级别使用进程
        某些变成予以按被设计为可以将并发任务彼此隔离，这些语言通常称为函数型语言
        21.1.1 更快的执行
        21.1.2 改进代码设计
            单机多线程
            分布式多线程
    21.2 基本的线程机制
        使用线程机制是一种简历透明的，可扩展的程序的方法
        21.2.1 定义任务
             使用实现 Runnable 方式定义任务
             Thread.yield()的调用是线程调度器，它在声明：“我已经完成声明周期中最重要的部分了，可以切换给其他任务执行一段时间的大好实际”
        21.2.2 Thread类
             new Thread(new LiftOff()).start 使用这个调用线程，启动线程
        21.2.3 使用Executor
            java.util.concurrent 执行器Executor 管理Thread对象
            ExecutorService exec = Executors.newCachedThreadPool();
            exec.execute(new LiftOff());
            FlxedThreadPool使用了有限的线程池来执行所提交任务
            SingleThreadExecutor就像是线程数量为1的FixedThreadPool 适用于长期存活的任务
        21.2.4 从任务中产生返回值
            如果你希望任务完成时能给你返回一个值，使用Callable接口
        21.2.5 休眠
            TimeUnit.MILLISECONDS.sleep(100);
        21.2.6 优先级
            线程优先级将该线程的重要性传递给了调度器，尽管CPU处理现有线程集的顺序是不确定的，但是调度器将倾向于让优先权最高的线程有限执行。
            然而，这并不是以为这优先权较低的线程得不到执行（优先权不会导致死锁）。优先级较低的线程仅仅是执行的频率较低
            所有线程都应该以默认的优先级运行。视图操纵线程优先级通常是一种错误
            三种优先级别 MAX_PRIORITY,NORM_PRIORITY_MIN_PRIORITY
        21.2.7 让步
            使用yield() 进行让步，但是只是让步，并不会保证可以让步成功
        21.2.8 后台线程
            所有后台线程，是指在程序运行的时候在后台提供一种通用服务的线程，并且这种线程并不属于程序中不可或缺的部分。因此，当所有的非后台线程结束时，程序也就终止了，同事会杀死进程中的所有后台线程
            。返回来说，只要有任何非后台线程在在运行，程序就不会终止，比如main方法就是非后台线程
            setDaemon(true);
        21.2.9 编码的本体
            继承 Thread 方法 开启线程
            通过 toString() 重写方式命名线程
            可以使用内部类来创建线程
        21.2.10 术语
        21.2.11 加入一个线程
            一个线程可以在其他线程之上调用join()方法，其效果是等待一段时间直到第二个线程结束才继续执行。
            如果某个线程在另一个线程上调用t.join次线程将被挂起，直到目标t结束才恢复
            也可以在调用join（）传入一个超时参数（单位毫秒，或者纳秒），这样如果目标线程没结束，join()方法总能返回
            对join()调用可以被终端，做法是调用interrupt()方法
            CyclicBarrler 比join更加适合
        21.2.12 创建有响应的用户界面
        21.2.13 线程组
            线程组持有一个线程集合。线程组的价值可以引用Joshua Bloch的话来总结： 最好把线程组看成是一次不成功的尝试，你只要忽略它就好了
            继续错误的代价由别人来承担，而诚然错误的代价由自己承担
        21.2.14 捕获异常
            由于线程的本质特性，使得你不能捕获从线程中逃逸的异常。一旦异常逃出任务的run()方法，它就会向外传播到控制台，除非你才去特殊的步骤捕获这种错误的异常。
            解决这个问题 ，我们修改Executor产生线程的方式，Thread.UncaughtExceptionHandler
    21.3 共享受限资源
        常规都是将每个线程只处理单一任务，不处理共享的变量，就不会产生问题，但是会经常遇到多个线程彼此互相干涉的问题
        21.3.1 不正确滴访问资源
            两个数据都操作同一个资源，可能存在重复修改的问题
        21.3.2 解决共享资源竞争
            假设你在桌子吃最后一个食物，当你拿起叉子去插它，结果突然发现食物消失了，因为你的线程被挂起来了，而另一个人吃掉了他
            对于并发工作，你需要某种方式来防止两个任务访问相同的资源，至少在关键阶段不能出现这种情况
            通常使用在代码前加一个锁来实现的，锁是互相排斥的，这种机制称为互斥量
            java 以提供关键字 synchronized形式，防止资源冲突提供了内置支持
            如果你正在写一个变量，它可能接下来将被另一个线程读取，火证正在读取一个上一次已经被另一个线程写过的变量，那么你必须使用同步，并且，读写线程都必须用相同的监视器同步
            同步控制EvenGenerator  publicc synchronized int next(){}
            使用显示的Lock对象 Lock lock =  new ReentrantLock() 记得在finally 适应unlock 来关掉锁 并且清理一些事情，要比synchronized好一些
            用synchronized关键字不能尝试着获取锁切最终获取做会失败，或者尝试着获取锁一段时间，然后放弃它，要实现这些就只能用lock来实现
        21.3.3 原子性与易变性
            原子操作是不能被线程调度机制终端的操作
            使用volatitle 来实现原子性
            如果对volatile进行写操作，那么所有读操作都可以看到这个修改，volatile域会立即写入到主存中
            如果多个任务同事访问某个域，那么这个域应该是volatile，如果使用了锁，则可以不使用这个
            但是，volatile并不能对递增不是原子性操作者一事实产生影响
        21.3.4 原子类
            AtomicInteger,AtomicLong,AtomicReference等特殊的原子性变量类
        21.3.5 临界区
            synchronized(Object){}
            称为同步控制块，进入此代码前，必须得到syncObject对象的锁，
        21.3.6 在其他对象上同步
            public synchronized void f(){}
        21.3.7 线程本地存储
            ThreadLocal对象通常当做静态域存储。在创建ThreadLocal你只能通过get()和set()方法来访问该对象的内容
    21.4 终结任务
        cancel()和isCanceled()都是终结方法，但是某些时候你要突然终止这个程序
        21.4.1 装饰性花园
            没看懂....
        21.4.2 在阻塞时终结
            线程的状态
            一个线程可以出于以下四种状态
            1.新建(new): 当线程被创建时，它只会端在滴出于这种状态。此时它已经分配了必须的系统资源，并执行了初始化。此刻线程已经有资格获得CPU时间了，之后调度器将把这个线程转变为可运行；这不同于死亡和阻塞状态。
            2.就绪(Runnable): 在这种状态下，只要调度器把时间分片给线程，线程就可以运行。也就是说，在任意时刻，线程可以运行也可以不运行。只要调度器能分配时间片给线程，它就可以运行；这不同于死亡和阻塞状态
            3.阻塞(Blocked): 线程能够运行，担有某个条件阻止它的运行。当线程出于阻塞状态时，调度器将忽略线程，不会分配给线程任何CPU时间。知道线程重新进入了就绪状态，它才有可能执行操作
            4死亡(Dead): 处于死亡或终止状态的线程将不再是可调度的，并且再也不会得到CPU时间，它的任务已经结束，或不再是可运行的。任务死亡的通常方式是从run()方法返回，但是任务的线程还可以被终端，你将要看到这一点
            进入阻塞状态
            一个任务进入阻塞状态，可能有如下原因：
            1. 通过调用sleep(milliseconds)使任务进入休眠状态，在这种情况下，任务在指定的时间内不会运行。
            2. 你通过调用wait()使线程挂起。直到线程得到了notify()或notifyAll()消息，线程才会进入就绪状态，
            3. 任务在等待某个输入/输出完成
            4.任务视图在某个对象上调用其同步控制方法，但是对象锁不可用，因为另一个任务已经获取了这个锁
        21.4.3 终端
            新的concurrent类库似乎在避免对Thread对象的直接操作，尽量通过Executor来操作，所以使用 Execuotr上调用shutdownNow(),那么它将发送一个interrupt()调用给它启动的所有线程。
            调用submit()而不是excetutor()来启动任务，就可以持有该任务的上下文。submit()将返回泛型Future，其中有一个未修饰的参数，可以用Future关键字调用cancel终端任务，cancel是终端由Exceutor启动单个线程的方式
            证明synchronized快上的等待是不可中断的
            被互斥阻塞
        21.4.4 检查中断
            使用interrupt()来设置中断，
    21.5 线程之间的协作
        21.5.1 wait()与notifyAll()
            使用 wait() notifAll() notfy() 来阻塞线程
            1. 在wait()期间对象锁是释放的
            2. 可以通过notify(), notifyAll(),或者令时间到期，从wait()中恢复执行
            错失信号
            当两个线程使用 notify()/wait()活notifyAll()/wait() 协作时，有可能会错过某个信号。假设T1是通知T2的线程，而这两个线程都是缺陷方式实现的
        21.5.2 notify()与notifyAll()
            如果只想唤醒指定的锁，就使用notify()
        21.5.3 生产者与消费者
            使用显式的Lock和Codintion对象
            使用互斥并允许任务挂起的基本类是Codition，你可以通过在Condition上调用await()来挂起一个任务
            可以使用 singnal()来通知这个任务，也可以调用singnalAll()唤醒所有这个Condition的任务
            与使用notifyAll()相比，signalAll()是更安全的方式
            private Condition condition = lock.newCondition()
        21.5.4 生产者-消费者与队列
            使用同步队列来解决任务协作问题，同步队列任何时刻只允许一个任务插入或移除元素
            java.util.concurrent.BlockingQueue
            ArrayBlockingQueue，具有固定尺寸，在阻塞时放入有限数量的元素
            吐司BlockingQueue
        21.5.5 任务间使用管道进行输入/输出
    21.6 死锁
        某个任务在等待另一个任务，而后者又等待别的任务，这样一直等下去，直到这个链条上的任务又在等待第一个任务释放锁，这得到了一个任务之间相互等待的连续循环，没有哪个线程能继续。这被称之为死锁
        一下四个条件都满足就会繁盛死锁
        1. 互斥条件。任务使用的资源中至少有一个是不能共享的。这里，一根Chopstick一次就只能被一个Philosopher使用
        2. 至少有一个任务它必须持有一个资源且正在等待获取一个当前被别的任务持有的资源。也就是说，要发生死锁，Philosopher必须拿着一个Chopstick并且等待另一根
        3. 资源不能被任务抢占，任务必须吧资源当做普通时间。
        4. 必须由循环等待，这时，一个任务等待其他任务锁持有的资源，后者又在等另一个任务锁持有的资源，这样一直下去，知道有一个任务在等待第一个任务锁持有的资源，使得大家都被锁住
    21.7 新类库中的构件
        21.7.1 CountDownLatch
            它被用来同步一个或多个任务，强制他们等待由其他任务执行的一组操作完成
            你可以定义个初始计算值，人这个这个对象调用wait()的方法都将阻塞，直至这个计数值为0，可以在调用countDown()来减小这个计数值
            countDownLatch被设计只触发一次，计数值不被重置，如果需要重置版本，可以使用CyclicBarrier
        21.7.2 CyclicBarrier
            你希望创建一组任务，他们并行地执行工作，然后再进行下一个步骤之前等待，直至所有任务都完成，它使得所有任务都将在栅栏处列队，可以一致地向前移动
            可以向CyclicBarrier提供一个 “栅栏动作”， 它是一个Runnable,当计数值到达0时，自动执行，这是CycleARRIER和CountDownLatch之间的另一个区别，
        21.7.3 DelayQueue
            这是一个无界的BlockingQueue,用于放置实现了Delayed接口的对象，其中的对象只能在其到期时才能从队列中取走，这种队列是有序的，即队头对象的延迟到期的时间最长。如果没有延迟到期，那么久不会有任何头元素，并且poll（）将返回null
            DelayedTask包含一个称为sequence的List<DelayedTask>
            Delayed接口有一个方法名为getDelay(),它可以用来告知延迟到期多长时间，或者延迟在多长时间之前已经到期
        21.7.4 PriorityBlockingQueue
            这是一个很基础的优先级队列，它具有可阻塞的读取操作。下面是一个示列，其中在优先级队列中的对象是按照优先顺序从队列中出现的任务。PrioritizedTask被赋予了一个优先级数字
        21.7.5 使用ScheduledExecutor的温室控制器
             通过schedule() （运行一次任务） 或者scheduleAtFixedRate() 每隔规则的时间重复执行任务，你可以将Runnable对象设置为在将来的某个时刻执行。
        21.7.6 Semaphore
            正常的锁（来自concurrent.locks或内键的synchronized锁）在任何时刻都只允许一个任务访问一项资源，而计数信号量 允许n个任务同事访问这个资源。
            你还可以将信号量看做是在向外分发使用资源的“许可证”，尽管实际上没有使用任何许可证对象
            作为一个示例，请考虑对象池的概念，它管理者数量有限的对象，当要使用对象时可以签出他们，而在用户使用完毕时，可以将他们签回。这种功能也可以封装到一个泛型类中
        21.7.7 Exchanger
            是在两个任务之间交换对象的栅栏，当这些任务进入栅栏时，他么各自拥有一个对象，当他们离开时，他们都拥有之前由对象持有的对象。典型场景是：一个任务在创建对象，这些对象的生产代价高昂，而另一个任务在消费这些对象。通过这种方式，可以有更多的对象在被创建的同时被被消费
    21.8 仿真
        21.8.1 银行出纳员仿真
        21.8.2 饭店仿真
        21.8.3 分发工作
    21.9 性能调优
        21.9.1 比较各类的互斥技术
            synchronized lock atomic 的速度更应该使用 atomic，但是仅限这个对象比较简单会更好
        21.9.2 免锁容器
            这些免锁容器背后的通常策略是：对容器的修改可以与读取操作同时发生，只要读取着只能看到完成修改的结果即可。修改是在容器数据结构的某个部分的一个单独的副本（有时是整个数据结构的副本）
            上执行的，并且这个副本在修改过程中是不可视的。只有当修改完成时，被修改的结构才会自动地与主数据结构进行交换，之后读取着就可以看到这个修改了
            在CopyOnWriteArrayList中，写入将导致创建整个底层数组的副本，而源数组将保留在原地，使得复制的数组在被修改时，读取操作可以安全滴执行。当修改完成时，一个原子性的操作将把新的数组换入，使得新的读取操作可以看到这个新的修改
            CopyOnWriteArraySet将使用CopyOnWriteArrayList来实现其免锁行为
            ConcurrentHashMap和ConcurrentLinkedQueue使用了类似的技术，允许并发的读取和写入，但是容器中只有部分内容而不是整个容器可以被复制和修改。然而，任何修改完成之前，读取着仍旧不能看到它们
            乐观锁
            只要你主要从免锁容器中读取，那么它就会比其synchronized对应物快许多，因为获取和释放锁的开销被省掉了
        21.9.3 乐观加锁
            使用compareAndSet()的方法
            你将旧址和新值一起提交这个方法，如果旧值与他在Atomic对象中发信的值不一致，那么这个操作就失败
        21.9.4 ReadWriteLock
            ReadWRITElOCK对向数据结构相对不频繁地写入，但是有多个任务要经常读取这个数据结构的这类情况进行了优化。ReadWriteLock使得你可以同时有多个读取着，只要它们都不视图写入即可。
            如果写锁已经被其他任务持有，那么任何读取着都不能访问，直至这个写锁被释放为止。
            使用ReentrantReadWriteLock，就会发现有大量的其他方法可用，涉及公平性和政策性决策等问题。这是一个相当复杂的工具，只有当你在搜索可以提高性能的方法时，才应该想到用它。
    21.10 活体对象
        主要是面向过程的方法，而有一种可以替换的方法称为活动对象或行动者，是面向对象的方式
        1. 每个对象都可以拥有自己的工作器线程
        2. 每个对象都将维护对它自己的域的全部控制权
        3.所有在活动对象之间的通信都将以在这些对象之间的消息形式发生
        4. 活动对象之间的所有消息都要排队
    21.11 总结
        1. 可以运行多个独立的任务
        2. 必须考虑当这些任务关闭时，可能出现的所有问题
        3. 任务可能会在共享资源上彼此干涉。互斥(锁)是用来防止这种冲突的基本工具
        4. 如果任务设计的不够仔细，就有可能死锁
        要明白什么时候使用并发 什么时候不使用
        1.要处理很多任务，它们交至在一起，应用并发能够更有效地使用计算机
        2.要能够更好地组织代码
        3.要更便于用户使用
        多线程的主要缺陷有
        1. 等待共享资源的时候性能降低
        2. 需要处理线程的额外CPU花费
        3. 糟糕的程序设计导致不必要的复杂度
        4. 有可能产生一些病态行为，如饿死，竞争，死锁，活锁（多个运行各自的任务的线程使得整体无法完成）
        5. 不同平台导致的不一致性


