---- 从头开始，复习一遍
第一章 对象导论
    面向对象设计（OOP）
    1.1 抽象过程
        基于汇编语言的基础，我们产生了多种语言，但是我们的行为都是按照机器来制作的，而并不适用现实的事件，那么我们就需要让现实和机器联合起来，抽象出一些东西，让他们满足一些特性和行为，则就是对象的做法
        smalltalk的五种基本特性
            1. 万物皆为对象
            2. 程序是对象的集合，他们通过发送消息来告知彼此要做的事情
            3. 每个对象都有自己的由其他对象所构成的存储
            4. 每个对象都拥有其类型
            5. 某一特定类型的所有对象都可以接收同样的消息
    1.2 每个对象都有一个接口
    1.3 每个对象都提供服务
    1.4 被隐藏的具体实现
        private proteated public
    1.5 复用具体实现
        每个类可能存在多个类，这些类是通过相互组合的方式实现方法，这些已有的类组合成新的类就是组合的方式，如果是动态的组合 就是聚合的方式，比如汽车拥有发动机
    1.6 继承
        我们拥有一个已有的类，但是不想再这个类上修改，我们可以选择创建一个类，来复制他，然后再这个新类增添内容，就是继承，继承的子类可以覆盖父类的方法，这样使用时就可以使用子类的新方法
        1.6.1 是一个 与 像是一个的关系
            是一个 就是 子类继承父类后，不会在增加多余的方法，只会覆盖父类的方法，保证还都是一类生物
            像是一个 则是 子类继承父类后，在此救赎又增加了自己的独有的方法，这样就是像是一类生物，但是里面是不同的
    1.7 伴随多态的可互换类型
        我们可以用一个父类，比如几何图形，让下面具体的图形继承这个父类，当我们要用几何绘制图形时，可以用父类来调用方法，而当我们使用时，就用具体的实现来构建，也就是在执行时，才知道将用哪个图形绘制，就是多态。
    1.8 单根继承结构
        所有的类都拥有唯一的父类就是Object的类，也是由C传播过来导致的，单根的好处首先是保证了整个类逻辑准群，其次为垃圾回收提供良好的简便性
    1.9 容器
        容器 也就是集合，用于存储一类的对象的集合，java自身就提供了很多容器
        1.9.1 参数化类型
            参数化类型也就是泛型，在java5 之前是没用泛型的，所以统一会传Object 作为容器的对象，但是当具体使用时就涉及到了类型转换，而后期推出了泛型，也就是可以指定一个对象的容器
    1.10 对象的创建和生命期
        我们每当使用一个对象要关心他的创建和销毁，因为对象不可能长时间存在，否则会对内存有很大的压力，那么他什么时候销毁呢，如果放在战中，计算机知道什么时候销毁，但是无法确定他所占用的大小，操作很麻烦，而放在堆中则可以
        不用管他的空间大小，使用多少就可以扩容，但是不知道什么时候不被使用了，java推出了垃圾回收机制， 定期的扫描堆中的对象，如果发现可以回收了，就可以动态的回收
    1.11 异常处理：处理错误
        大部分语言都没法子提供很强的异常容错率，遇到问题都交给开发者来解决异常，java也是，java唯一提供的是在编译时如果语法不规则，编译就不会通过，但是太复杂的时候也不会查出来
    1.12 并发编程
    1.13 java与Internet
        1.13.1 web是什么
        1.13.2 客户端编程
            插件、脚本、java、C#、javaScript...
        1.13.3 服务器端编程

第二章 一切都是对象
    2.1 用引用操作对象
    2.2 必须由你创建所有对象
        使用 new 来创建所有对象
        2.2.1 存储到什么地方
            1. 寄存器 速度很快，但是空间太小了
            2. 堆栈 空间限制无法任意搞
            3. 堆中 空间合适
            4. 常量存储
            5. 非RAM存储
        2.2.2 特例：基本类型
            创建对象都是用new来创建，而基本类型过于小，用new创建太浪费，因此是以值的形式，直接存储在堆中。
            java的基本类型
            --------------------------------------------
            基本类型 大小 最小值 最大值 包装类型
            boolean - - - Boolean
            char 16bit Unicode0 Unicode2^16-1 CharaCter
            byte 8bit -128 127 Byte
            short 16bit -2^15-1 2^15-1 Short
            int 32bit -2^31-1 2^31-1 Integer
            long 64bit -2^63-1 2^63-1 Long
            float 32bit IEEE754 IEEE754 Float
            double 64bit IEEE754 IEEE754 Double
            void - - - Void
            --------------------------------------------
            高精度数据  bigInteger(整数) bigDecimal（浮点数）
        2.2.3 java的数组
    2.3 永远不要销毁对象
        2.3.1 作用域
        2.3.2 对象作用域
    2.4 创建新的数据类型 类 class
        2.4.1 字段和方法
            基本成员的默认值
                类型 默认值
                boolean false
                char '\u0000'
                byte 0
                short 0
                int 0
                long 0L
                float 0.0f
                double 0.0d
    2.5 方法参数和返回值
        2.5.1 参数列表
    2.6 构建一个java程序
        2.6.1 名字可见性
            引入了package 来保证名字的唯一性
        2.6.2 运用其他构建
            import 关键字，导入指定要的包
        2.6.3 static 关键字
            独属于一个空间，可以直接通过类名调用，一个改变全局都改变
    2.7 你的第一个java程序
    2.8 注释和嵌入式文档
        2.8.1 代码注释
        2.8.2 语法
        2.8.3 嵌入式HTML
        2.8.4 一些标签类型
            @see 引用其他类
            @link 引用其他类 展示不同
            @version 版本
            @author 作者
            @since 最早版本
            @param 参数说明
            @return 返回值描述
            @throws 异常
            @deprecated 就特性被新特性取代
    2.9 编码风格
    2.10 总结

第三章 操作符
    3.1 更简单的打印语句
    3.2 使用java操作符
    3.3 优先级
    3.4 赋值语句 =
        把右边的值 赋给 左边
    3.5 算数运算符
        3.5.1 一元 加 和一元 减
    3.6 自动递增和递减
        前缀式 和后缀式， 前缀式就是在表达式或者变量的前面， 后缀式就是变量或表达式的后面
    3.7 关系操作符
        > < >= <= == !=
        3.7.1 测试对象的等价性
    3.8 逻辑操作符
        && || ！
        3.8.1 短路
    3.9 直接常量
        十六进制 前0X
    3.10 换位操作符  & | ！
    3.11 移位操作符 <<  >>
    3.12 三元操作符 if-else  boolean ? x : y
    3.13 字符串 + += 的区别
    3.14 使用操作符 常犯的错误
    3.15 类型转换操作符  cast
        3.15.1 截尾 和舍入
        3.15.2 提升
    3.16 java没有sizeof
    3.17 操作符小结

第四章 控制执行流程
    4.1 true 和false
    4.2 if- else
    4.3 迭代 while (do while) for
        4.3.3 逗号的作用
    4.4 foreach 的写法
    4.5 return
    4.6 break continue
    4.7 臭名昭著的goto
        java 没有实现 goto ，而是用标签的方法来代替这种 跳来跳去的 流程
    4.8 switch case default

第五章 初始化与清理
    5.1 用构造器确保初始化
        构造器是用来初始化类的，当程序调用时，就默认分配了一定的空间给这个对象
        构造器分无惨构造器，有参构造器
        无惨构造器是java所有类默认有的，但是当你指定了构造器，这个就会消失
        构造器的函数名是要和类名保持一致
    5.2 方法的重载
        方法的重载 出生其实是因为构造器不能只有一个，而一个函数的名字是要固定的，那么要想有多个构造器，就需要重载来支撑这个
        5.2.1 区分重载的方法
            每个方法都要有独一无二的参数列表
        5.2.2 涉及基本类型的重载
            要注意 参数的默认转换 比如 short 会自动变成int，传入时就要指定参数类型
        5.2.3 以返回值区分重载方法
    5.3 默认构造器
    5.4 this关键字
        this关键字只能在方法内部使用，表示调用方法那个对象 的引用
        5.4.1 在构造器中调用构造器
            可以通过this 来调用当前对象里的其他构造器
        5.4.2 static的含义
            static中不能调用this，因为不属于一个对象，属于全局的，如果有太多的static，那么这可能就不是面向对象的思想了
        5.5 清理： 中级处理和垃圾回收
            finalize() 方法，不会直接清理的，只是会告诉jvm，当清理的时候 可以清理我这里，更像是一个标记吧
            1. 对象可能不被垃圾回收
            2. 垃圾回收并等于 “析构”
            5.5.1 finalize()的用途何在
                3. 垃圾回收只与内存有关
            5.5.2 你必须实施清理
                意思是如果jvm没有面临内存不够用的时候，是不糊进行垃圾回收清理的，将资源浪费在这个上面
                并且，终结、垃圾回收，都不是一定会去执行的
            5.5.3 终结条件
                当我们用finalize（）方法重新打上标签时，当jvm垃圾回收 或者 system.gc()的时候可能会发现问题进行清理
            5.5.4 垃圾回收器如何工作的
                引用技术法：
                    是一种很简单，但是很慢的垃圾回收技术，每个对象都含有一个引用计数器，当引用增加时 引用就+1,当引用离开时，就置位null
                    但是这种会出现问题，就是如果有循环引用，那么对象可能就无法被回收
                停止-复制 （stop-and-copy）
                    先暂停程序运行，将堆里的对象复制到另一个堆，如果没有复制过去的就说明是垃圾，直接清楚，而复制过去都是紧凑的内存空间，
                    缺点是 要有两个堆，要来回倒腾，
                标记-清楚（mark-and-sweep）
                    适用于少量垃圾甚至不产生垃圾时，这个算法就很快，否则就很慢
                    同样是从堆栈和静态存储区域触发，遍历所有的引用，进而找出存活的对象，打上标记，这个时候不会回收对象，标记完成后，进行清理
                    没有标记的对象会被释放
                自适应技术
                    jvm会根据当前的情况 自动切换回收算法， 自适应的，分代的，停止-复制，标记-清除
                即时（Just-In-Time,JIT）
                    编译器技术，会把所有或者部分类加载到本地机器码中，当使用某个类时，会找到这个.class 将他装在到内存
                    两种方法
                        1. 就是启动时装载所有的类
                        2. 惰性评估，就是需要时才加载
                        新版本JDK Java HotSpot技术采用类似方法，所以执行次数会越来越快
        5.6 成员初始化
            5.6.1 指定初始化
        5.7 构造器初始化
            5.7.1 初始化顺序
                就是类属性拥有默认值，在构造器中会重新对值进行初始化
            5.7.2 静态数据的初始化
                先静态对象，后非静态对象
            5.7.3 显式的静态初始化
                静态代码块的使用
            5.7.4 非静态实例初始化
        5.8 数组的初始化
            int [] al 等价 int al []
            数组创建时，必须指定空间大小或者元素内容
            5.8.1 可变参数列表
                void printArray(Objecs... args)

        5.9 枚举类型
            使用enum 来标记，可以搭配switch语句使用

        5.10 总结

第六章 访问权限控制
    访问控制（或隐藏具体实现） 与 “最初的实现并不恰当” 有关
    public protected 包访问权限（没有关键字） 和private
    6.1 包： 库单元
        package 关键字的使用 ，代表某个域下的类
        6.1.1 代码组织
            使用package 声明包的位置，使用import 导入指定的类
        6.1.2 创建独一无二的包名
            java解释器的过程如下
                首先，找出环境变量CLASSPATH，CLASSPATH包含一个或多个目录，用作查找.class文件的根目录。
                从根目录开始，解释器获取包的名称并将每个句点替换成反斜杠。
                得到的路径会与CLASSPATH中的哥哥不同的链接，
                解释器就在这些目录中查找与你所要创建的类名称相关的.class文件

        6.1.3 定制工具库
        6.1.4 用import改变行为
        6.1.5 对使用包的忠告
    6.2 Java访问权限修饰词
        public， protected， private 这几个Java访问权限修饰词
        6.2.1 包访问权限
            也被称为friendly
        6.2.2 public： 接口访问权限
        6.2.3 private： 你无法访问
        6.2.4 protected：继承访问权限

    6.3 接口和实现
        访问权限的控制常被称为是具体实现的隐藏，把数据和方法包装进类中，以及具体实现的隐藏，常共同被称作为封装。

    6.4 类的访问权限
        1. 每个编译单元 都只能有一个public类
        2. public类的名称必须完全与含有该编译单元的文件名相匹配，包括大小写
        3. 虽然不是很常用，但编译单元内完全不带public类也是可能的

    6.5 总结

第七章 复用类
    复用代码是java众多引人注目的功能之一。但要想成为极具革命性的语言，仅仅能够复制代码并对之加以改变是不够的，它还必须能够做更多的事情
    7.1 组合语法
    7.2 继承语法
        关键字 extends
        关键字 super 表示超类
        子类在构造时，父类也会同时被构造了，构建过程是向外扩散的
    7.3 代理
        就是A类有很多动作，而B类要用A类的动作，将A类对象放入B类中，将B类对外暴露，由B类调用A类里的方法，使用B类代理A类使用，实际功能是A累的功能
    7.4 结合使用组合和继承
        7.4.1 确保正确清理
            使用try +finally 来处理数据一定被清洗和执行
        7.4.2 名称屏蔽
            利用@Override 来重写超类里面的方法
    7.5 在组合与继承之间选择
        判定 两个对象是 is-a 的关系还是 has-a 的关系，来选择使用继承还是组合
    7.6 protected 关键字
        只允许子类可以访问的 关键字，但是对于其外部来说还是private的
    7.7 向上转型
        用父类声明，用子类实现，代表向上转型
        有哪些方法是看声明类，而具体实现则是看实现类
        7.7.1 为什么称为向上转型
            因为是用超类来声明，将子类往超类上转换，所以是向上转型
        7.7.2 再轮组合和继承
            对于OOP 来说，我们应该使用继承，但是继承的关系不能乱用，我们参考的方法就是，是否真的需要向父类转换，如果是，那就一定要使用继承
    7.8 final 关键字
        这是无法改变的含义的关键字，可以使用三种地方 数据 方法 和类
        7.8.1 final 数据
            1. 一个永不改变的编译时常量
            2. 一个运行时被初始化的值，而你不希望它被改变
            空白final 必须要保证初始化时给他值
        7.8.2 final方法
            使用final的方法，无法被子类进行重写 覆盖
            private 和final ，private已经暗示这个方法为final了
        7.8.3 final 类
            当将某个类的整体定义final，就不允许再有类继承他，从设计上看，这个类不需要任何变动，从安全考虑，这个类不需要在被继承
        7.8.4 有关final的忠告
    7.9 初始化及类的加载
        7.9.1 继承与初始化
            当一个基类被初始化时，首先找他的父类，就算没有明确继承也会找隐士的父类，然后会初始化父类，如果父类还有父类，会递归的向上初始化
            直到所有的都被初始化完成
    7.10 总结
        继承和综合都是交互使用，在恰当的使用可以让我们代码更有健壮性

第八章 多态
    在面向对象的程序设计语言中，多态是继数据抽象和继承之后的第三种基本特征
    动态绑定，后期绑定或运行时绑定

    8.1 再论向上转型
        8.1.1 忘记对象类型
    8.2 转机
        8.2.1 方法调用绑定
            将一个方法调用同一个方法主体关联起来被称为绑定。若在程序执行前进行绑定（如果有的话，由编译器和链接程序实现）叫做前期绑定
            后期绑定：在运行时根据对象的类型进行绑定，后期绑定也叫运行时绑定或动态绑定
            java 除了 static final private 方法 都可以做后期绑定
        8.2.2 产生正确的行为
        8.2.3 可扩展性
            多态是让程序员 将改变的事物与未来的事物分离开来
        8.2.4 缺陷：“覆盖” 私有方法
            子类中是不会覆盖 超类的private方法，就算子类定义了一样的方法，就算名字相同，其实也是新的方法 独属于子类的方法
        8.2.5 缺陷： 域与静态方法
            静态的方法也不符合多态的规则
    8.3 构造器和多态
        构造器不同于其他种类的方法，构造器本质是静态的方法，只是不需要声明 static
        8.3.1 构造器的调用顺序
        8.3.2 继承与清理
        8.3.3 构造器内部的多态方法和行为
            准则： 用尽可能简单的方法使对象进入正常的状态；如果可以的话，避免调用其他方法。在构造器内唯一能够安全调用的那些2方法是基类中的final方法。
            这些方法不能被覆盖，因此也就不会出现问题
    8.4 协变返回类型
        表示在导出类中的呗覆盖方法可以返回基类方法的返回类型的某种导出类型
    8.5 用继承进行设计
        准则：用继承表达行为间的差异，并用字段表达状态上的变化
        8.5.1 纯继承与扩展
            纯粹 的 is-a 的关系 就很适合用继承
            而 is -like -a 像一个关系 子类扩展出其他的方法，如果用向上转型 就无法使用基类新的方法
        8.5.2 向下转型与运行时类型识别
            如果向下转型失败 会抛出异常ClassCaseException
    8.6 总结
        多态意味着 不同的形式。在面向对象的程序设计中，我们持有从基类继承而来的相同接口，以及使用该接口的不同形式，不同版本的动态绑定方法

第九章 接口
    接口和内部类为我们提供了一种将接口与实现分离的更加结构化的方法
    9.1 抽象类和抽象方法
        abstract void f(); 抽象方法， 只有声明，没有实现
        包含这种方法的类 叫做抽象类  absttract class
    9.2 接口
        interface关键字 定义接口
        一个接口表示： 所有实现了该特定接口的类看起来都像这样
        类要实现接口 需要使用关键字 implemens
        接口里的方法都是public 默认如此
    9.3 完全解耦
    9.4 java中的多重继承
        接口可以使用 多重继承，就好比一个类实现多个接口，就要实现多个接口里的方法
    9.5 通过继承来扩展接口
        通过继承，可以很容易地在接口中添加新的方法声明，还可以通过继承在新接口中组合数个接口。这两种情况都可以获得新的接口
        9.5.1 组合接口时的名字冲突
            要注意这种情况
    9.6 适配接口
    9.7 接口中的域
        接口里的函数和常量都是 static final 形式的 可以用他来定义常量
        9.7.1 初始化接口中的域
    9.8 嵌套接口
        在类中 嵌套接口 在类中在实现它，感觉使用并不高，只是一种支持写法
    9.9 接口与工厂
        接口尝尝用来实现工厂模式
    9.10 总结
        确定接口是理想乡选择，因而应该总是选择接口而不是具体的类

第十章 内部类
    可以将一个类的定义放在另一个类的定义内部，这就是内部类
    10.1 创建内部类
        普通内部类， 静态内部类， 匿名内部类 局部内部类
    10.2 链接到外部类
        将内部类的对象作为一个引用发到外部类中
    10.3 使用.this与.new
    10.4 内部类与向上转型
    10.5 在方法和作用域内的内部类
        要解决一个复杂的问题，又不希望外部可以访问这些类的定义，可以使用内部类来组合使用
    10.6 匿名内部类
        匿名内部类没有构造器
        10.6.1 在访工厂方法
            使用内部类实现工厂类
    10.7 嵌套类
        如果不需要内部类对象与其外围类对象之间有联系，那么可以将内部类声明为static。这通常为嵌套类
        10.7.1 接口内部的类
            可以用内部类 来写测试接口 就很隔离
        10.7.2 从多层嵌套类中访问外部类的成员
            内部类中可以调外部类的属性 尽管他是private的
    10.8 为什么需要内部类
        每个内部类都能独立地继承自一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响。
        内部类可以有多个实例，每个实例都有自己的状态信息，并且与其外围类对象的信息相互独立
        在单个外围类中，可以让多个内部类以不同的方式实现同一个接口，或继承同一个类
        创建内部类对象的时刻并不依赖于外围类对对象的创建。
        内部类并没有令人迷惑的is-a关系，它就是一个独立的实体
        10.8.1 闭包与回调
            闭包（closure）是一个可调用的对象，它记录了一些信息，这些信息来自于创建它的作用域，通过这个定义，可以看出内部类是面向对象的闭包，因为它不仅包含外围类对象的信息，还自动拥有一个指向此外围类对象的引用，在此作用域内，内部类有权操作所有的成员，包括private程璇
        10.8.2 内部类与控制框架
            多个控制框架（control framework）
            用用程序框架（application framework） 模板设计模式
            事件驱动系统  经典例子：图形用户接口GUI
    10.9 内部类的继承
        内部类的构造方法会相对复杂化，必须使用sper这种方式才可以通过
    10.10 内部类可以被覆盖么
        当继承了某个外围类的时候，内部类没有发生神奇的变化，这两个内部类是完全独立的实体，各自在自己的命名空间内
    10.11 局部内部类
        在方法里创建内部类，就属于局部内部类
        为什么要用局部内部类而不用匿名内部类呢？唯一的理由是 我们需要一个已命名的构造器，或者需要重载构造器
    10.12 内部类的标识符
        每个类编译后都会有 名字.class 文件 而内部类则是 名字$内部类.class 这种表示
    10.13 总结

第十一章 持有对象




