---- 从头开始，复习一遍
第一章 对象导论
    面向对象设计（OOP）
    1.1 抽象过程
        基于汇编语言的基础，我们产生了多种语言，但是我们的行为都是按照机器来制作的，而并不适用现实的事件，那么我们就需要让现实和机器联合起来，抽象出一些东西，让他们满足一些特性和行为，则就是对象的做法
        smalltalk的五种基本特性
            1. 万物皆为对象
            2. 程序是对象的集合，他们通过发送消息来告知彼此要做的事情
            3. 每个对象都有自己的由其他对象所构成的存储
            4. 每个对象都拥有其类型
            5. 某一特定类型的所有对象都可以接收同样的消息
    1.2 每个对象都有一个接口
    1.3 每个对象都提供服务
    1.4 被隐藏的具体实现
        private proteated public
    1.5 复用具体实现
        每个类可能存在多个类，这些类是通过相互组合的方式实现方法，这些已有的类组合成新的类就是组合的方式，如果是动态的组合 就是聚合的方式，比如汽车拥有发动机
    1.6 继承
        我们拥有一个已有的类，但是不想再这个类上修改，我们可以选择创建一个类，来复制他，然后再这个新类增添内容，就是继承，继承的子类可以覆盖父类的方法，这样使用时就可以使用子类的新方法
        1.6.1 是一个 与 像是一个的关系
            是一个 就是 子类继承父类后，不会在增加多余的方法，只会覆盖父类的方法，保证还都是一类生物
            像是一个 则是 子类继承父类后，在此救赎又增加了自己的独有的方法，这样就是像是一类生物，但是里面是不同的
    1.7 伴随多态的可互换类型
        我们可以用一个父类，比如几何图形，让下面具体的图形继承这个父类，当我们要用几何绘制图形时，可以用父类来调用方法，而当我们使用时，就用具体的实现来构建，也就是在执行时，才知道将用哪个图形绘制，就是多态。
    1.8 单根继承结构
        所有的类都拥有唯一的父类就是Object的类，也是由C传播过来导致的，单根的好处首先是保证了整个类逻辑准群，其次为垃圾回收提供良好的简便性
    1.9 容器
        容器 也就是集合，用于存储一类的对象的集合，java自身就提供了很多容器
        1.9.1 参数化类型
            参数化类型也就是泛型，在java5 之前是没用泛型的，所以统一会传Object 作为容器的对象，但是当具体使用时就涉及到了类型转换，而后期推出了泛型，也就是可以指定一个对象的容器
    1.10 对象的创建和生命期
        我们每当使用一个对象要关心他的创建和销毁，因为对象不可能长时间存在，否则会对内存有很大的压力，那么他什么时候销毁呢，如果放在战中，计算机知道什么时候销毁，但是无法确定他所占用的大小，操作很麻烦，而放在堆中则可以
        不用管他的空间大小，使用多少就可以扩容，但是不知道什么时候不被使用了，java推出了垃圾回收机制， 定期的扫描堆中的对象，如果发现可以回收了，就可以动态的回收
    1.11 异常处理：处理错误
        大部分语言都没法子提供很强的异常容错率，遇到问题都交给开发者来解决异常，java也是，java唯一提供的是在编译时如果语法不规则，编译就不会通过，但是太复杂的时候也不会查出来
    1.12 并发编程
    1.13 java与Internet
        1.13.1 web是什么
        1.13.2 客户端编程
            插件、脚本、java、C#、javaScript...
        1.13.3 服务器端编程

第二章 一切都是对象
    2.1 用引用操作对象
    2.2 必须由你创建所有对象
        使用 new 来创建所有对象
        2.2.1 存储到什么地方
            1. 寄存器 速度很快，但是空间太小了
            2. 堆栈 空间限制无法任意搞
            3. 堆中 空间合适
            4. 常量存储
            5. 非RAM存储
        2.2.2 特例：基本类型
            创建对象都是用new来创建，而基本类型过于小，用new创建太浪费，因此是以值的形式，直接存储在堆中。
            java的基本类型
            --------------------------------------------
            基本类型 大小 最小值 最大值 包装类型
            boolean - - - Boolean
            char 16bit Unicode0 Unicode2^16-1 CharaCter
            byte 8bit -128 127 Byte
            short 16bit -2^15-1 2^15-1 Short
            int 32bit -2^31-1 2^31-1 Integer
            long 64bit -2^63-1 2^63-1 Long
            float 32bit IEEE754 IEEE754 Float
            double 64bit IEEE754 IEEE754 Double
            void - - - Void
            --------------------------------------------
            高精度数据  bigInteger(整数) bigDecimal（浮点数）
        2.2.3 java的数组
    2.3 永远不要销毁对象
        2.3.1 作用域
        2.3.2 对象作用域
    2.4 创建新的数据类型 类 class
        2.4.1 字段和方法
            基本成员的默认值
                类型 默认值
                boolean false
                char '\u0000'
                byte 0
                short 0
                int 0
                long 0L
                float 0.0f
                double 0.0d
    2.5 方法参数和返回值
        2.5.1 参数列表
    2.6 构建一个java程序
        2.6.1 名字可见性
            引入了package 来保证名字的唯一性
        2.6.2 运用其他构建
            import 关键字，导入指定要的包
        2.6.3 static 关键字
            独属于一个空间，可以直接通过类名调用，一个改变全局都改变
    2.7 你的第一个java程序
    2.8 注释和嵌入式文档
        2.8.1 代码注释
        2.8.2 语法
        2.8.3 嵌入式HTML
        2.8.4 一些标签类型
            @see 引用其他类
            @link 引用其他类 展示不同
            @version 版本
            @author 作者
            @since 最早版本
            @param 参数说明
            @return 返回值描述
            @throws 异常
            @deprecated 就特性被新特性取代
    2.9 编码风格
    2.10 总结

第三章 操作符
    3.1 更简单的打印语句
    3.2 使用java操作符
    3.3 优先级
    3.4 赋值语句 =
        把右边的值 赋给 左边
    3.5 算数运算符
        3.5.1 一元 加 和一元 减
    3.6 自动递增和递减
        前缀式 和后缀式， 前缀式就是在表达式或者变量的前面， 后缀式就是变量或表达式的后面
    3.7 关系操作符
        > < >= <= == !=
        3.7.1 测试对象的等价性
    3.8 逻辑操作符
        && || ！
        3.8.1 短路
    3.9 直接常量
        十六进制 前0X
    3.10 换位操作符  & | ！
    3.11 移位操作符 <<  >>
    3.12 三元操作符 if-else  boolean ? x : y
    3.13 字符串 + += 的区别
    3.14 使用操作符 常犯的错误
    3.15 类型转换操作符  cast
        3.15.1 截尾 和舍入
        3.15.2 提升
    3.16 java没有sizeof
    3.17 操作符小结

第四章 控制执行流程
    4.1 true 和false
    4.2 if- else
    4.3 迭代 while (do while) for
        4.3.3 逗号的作用
    4.4 foreach 的写法
    4.5 return
    4.6 break continue
    4.7 臭名昭著的goto
        java 没有实现 goto ，而是用标签的方法来代替这种 跳来跳去的 流程
    4.8 switch case default

第五章 初始化与清理
    5.1 用构造器确保初始化
        构造器是用来初始化类的，当程序调用时，就默认分配了一定的空间给这个对象
        构造器分无惨构造器，有参构造器
        无惨构造器是java所有类默认有的，但是当你指定了构造器，这个就会消失
        构造器的函数名是要和类名保持一致
    5.2 方法的重载
        方法的重载 出生其实是因为构造器不能只有一个，而一个函数的名字是要固定的，那么要想有多个构造器，就需要重载来支撑这个
        5.2.1 区分重载的方法
            每个方法都要有独一无二的参数列表
        5.2.2 涉及基本类型的重载
            要注意 参数的默认转换 比如 short 会自动变成int，传入时就要指定参数类型
        5.2.3 以返回值区分重载方法
    5.3 默认构造器
    5.4 this关键字
        this关键字只能在方法内部使用，表示调用方法那个对象 的引用
        5.4.1 在构造器中调用构造器
            可以通过this 来调用当前对象里的其他构造器
        5.4.2 static的含义
            static中不能调用this，因为不属于一个对象，属于全局的，如果有太多的static，那么这可能就不是面向对象的思想了
        5.5 清理： 中级处理和垃圾回收
            finalize() 方法，不会直接清理的，只是会告诉jvm，当清理的时候 可以清理我这里，更像是一个标记吧
            1. 对象可能不被垃圾回收
            2. 垃圾回收并等于 “析构”
            5.5.1 finalize()的用途何在
                3. 垃圾回收只与内存有关
            5.5.2 你必须实施清理
                意思是如果jvm没有面临内存不够用的时候，是不糊进行垃圾回收清理的，将资源浪费在这个上面
                并且，终结、垃圾回收，都不是一定会去执行的
            5.5.3 终结条件
                当我们用finalize（）方法重新打上标签时，当jvm垃圾回收 或者 system.gc()的时候可能会发现问题进行清理
            5.5.4 垃圾回收器如何工作的
                引用技术法：
                    是一种很简单，但是很慢的垃圾回收技术，每个对象都含有一个引用计数器，当引用增加时 引用就+1,当引用离开时，就置位null
                    但是这种会出现问题，就是如果有循环引用，那么对象可能就无法被回收
                停止-复制 （stop-and-copy）
                    先暂停程序运行，将堆里的对象复制到另一个堆，如果没有复制过去的就说明是垃圾，直接清楚，而复制过去都是紧凑的内存空间，
                    缺点是 要有两个堆，要来回倒腾，
                标记-清楚（mark-and-sweep）
                    适用于少量垃圾甚至不产生垃圾时，这个算法就很快，否则就很慢
                    同样是从堆栈和静态存储区域触发，遍历所有的引用，进而找出存活的对象，打上标记，这个时候不会回收对象，标记完成后，进行清理
                    没有标记的对象会被释放
                自适应技术
                    jvm会根据当前的情况 自动切换回收算法， 自适应的，分代的，停止-复制，标记-清除
                即时（Just-In-Time,JIT）
                    编译器技术，会把所有或者部分类加载到本地机器码中，当使用某个类时，会找到这个.class 将他装在到内存
                    两种方法
                        1. 就是启动时装载所有的类
                        2. 惰性评估，就是需要时才加载
                        新版本JDK Java HotSpot技术采用类似方法，所以执行次数会越来越快
        5.6 成员初始化
            5.6.1 指定初始化
        5.7 构造器初始化
            5.7.1 初始化顺序
                就是类属性拥有默认值，在构造器中会重新对值进行初始化
            5.7.2 静态数据的初始化
                先静态对象，后非静态对象
            5.7.3 显式的静态初始化
                静态代码块的使用
            5.7.4 非静态实例初始化
        5.8 数组的初始化
            int [] al 等价 int al []
            数组创建时，必须指定空间大小或者元素内容
            5.8.1 可变参数列表
                void printArray(Objecs... args)

        5.9 枚举类型
            使用enum 来标记，可以搭配switch语句使用

        5.10 总结

第六章 访问权限控制
    访问控制（或隐藏具体实现） 与 “最初的实现并不恰当” 有关
    public protected 包访问权限（没有关键字） 和private
    6.1 包： 库单元
        package 关键字的使用 ，代表某个域下的类
        6.1.1 代码组织
            使用package 声明包的位置，使用import 导入指定的类
        6.1.2 创建独一无二的包名
            java解释器的过程如下
                首先，找出环境变量CLASSPATH，CLASSPATH包含一个或多个目录，用作查找.class文件的根目录。
                从根目录开始，解释器获取包的名称并将每个句点替换成反斜杠。
                得到的路径会与CLASSPATH中的哥哥不同的链接，
                解释器就在这些目录中查找与你所要创建的类名称相关的.class文件

        6.1.3 定制工具库
        6.1.4 用import改变行为
        6.1.5 对使用包的忠告
    6.2 Java访问权限修饰词
        public， protected， private 这几个Java访问权限修饰词
        6.2.1 包访问权限
            也被称为friendly
        6.2.2 public： 接口访问权限
        6.2.3 private： 你无法访问
        6.2.4 protected：继承访问权限

    6.3 接口和实现
        访问权限的控制常被称为是具体实现的隐藏，把数据和方法包装进类中，以及具体实现的隐藏，常共同被称作为封装。

    6.4 类的访问权限
        1. 每个编译单元 都只能有一个public类
        2. public类的名称必须完全与含有该编译单元的文件名相匹配，包括大小写
        3. 虽然不是很常用，但编译单元内完全不带public类也是可能的

    6.5 总结

第七章 复用类
    复用代码是java众多引人注目的功能之一。但要想成为极具革命性的语言，仅仅能够复制代码并对之加以改变是不够的，它还必须能够做更多的事情
    7.1 组合语法
    7.2 继承语法
        关键字 extends
        关键字 super 表示超类
        子类在构造时，父类也会同时被构造了，构建过程是向外扩散的
    7.3 代理
        就是A类有很多动作，而B类要用A类的动作，将A类对象放入B类中，将B类对外暴露，由B类调用A类里的方法，使用B类代理A类使用，实际功能是A累的功能
    7.4 结合使用组合和继承
        7.4.1 确保正确清理
            使用try +finally 来处理数据一定被清洗和执行
        7.4.2 名称屏蔽
            利用@Override 来重写超类里面的方法
    7.5 在组合与继承之间选择
        判定 两个对象是 is-a 的关系还是 has-a 的关系，来选择使用继承还是组合
    7.6 protected 关键字
        只允许子类可以访问的 关键字，但是对于其外部来说还是private的
    7.7 向上转型
        用父类声明，用子类实现，代表向上转型
        有哪些方法是看声明类，而具体实现则是看实现类
        7.7.1 为什么称为向上转型
            因为是用超类来声明，将子类往超类上转换，所以是向上转型
        7.7.2 再轮组合和继承
            对于OOP 来说，我们应该使用继承，但是继承的关系不能乱用，我们参考的方法就是，是否真的需要向父类转换，如果是，那就一定要使用继承
    7.8 final 关键字
        这是无法改变的含义的关键字，可以使用三种地方 数据 方法 和类
        7.8.1 final 数据
            1. 一个永不改变的编译时常量
            2. 一个运行时被初始化的值，而你不希望它被改变
            空白final 必须要保证初始化时给他值
        7.8.2 final方法
            使用final的方法，无法被子类进行重写 覆盖
            private 和final ，private已经暗示这个方法为final了
        7.8.3 final 类
            当将某个类的整体定义final，就不允许再有类继承他，从设计上看，这个类不需要任何变动，从安全考虑，这个类不需要在被继承
        7.8.4 有关final的忠告
    7.9 初始化及类的加载
        7.9.1 继承与初始化
            当一个基类被初始化时，首先找他的父类，就算没有明确继承也会找隐士的父类，然后会初始化父类，如果父类还有父类，会递归的向上初始化
            直到所有的都被初始化完成
    7.10 总结
        继承和综合都是交互使用，在恰当的使用可以让我们代码更有健壮性

第八章 多态
    在面向对象的程序设计语言中，多态是继数据抽象和继承之后的第三种基本特征
    动态绑定，后期绑定或运行时绑定

    8.1 再论向上转型
        8.1.1 忘记对象类型
    8.2 转机
        8.2.1 方法调用绑定
            将一个方法调用同一个方法主体关联起来被称为绑定。若在程序执行前进行绑定（如果有的话，由编译器和链接程序实现）叫做前期绑定
            后期绑定：在运行时根据对象的类型进行绑定，后期绑定也叫运行时绑定或动态绑定
            java 除了 static final private 方法 都可以做后期绑定
        8.2.2 产生正确的行为
        8.2.3 可扩展性
            多态是让程序员 将改变的事物与未来的事物分离开来
        8.2.4 缺陷：“覆盖” 私有方法
            子类中是不会覆盖 超类的private方法，就算子类定义了一样的方法，就算名字相同，其实也是新的方法 独属于子类的方法
        8.2.5 缺陷： 域与静态方法
            静态的方法也不符合多态的规则
    8.3 构造器和多态
        构造器不同于其他种类的方法，构造器本质是静态的方法，只是不需要声明 static
        8.3.1 构造器的调用顺序
        8.3.2 继承与清理
        8.3.3 构造器内部的多态方法和行为
            准则： 用尽可能简单的方法使对象进入正常的状态；如果可以的话，避免调用其他方法。在构造器内唯一能够安全调用的那些2方法是基类中的final方法。
            这些方法不能被覆盖，因此也就不会出现问题
    8.4 协变返回类型
        表示在导出类中的呗覆盖方法可以返回基类方法的返回类型的某种导出类型
    8.5 用继承进行设计
        准则：用继承表达行为间的差异，并用字段表达状态上的变化
        8.5.1 纯继承与扩展
            纯粹 的 is-a 的关系 就很适合用继承
            而 is -like -a 像一个关系 子类扩展出其他的方法，如果用向上转型 就无法使用基类新的方法
        8.5.2 向下转型与运行时类型识别
            如果向下转型失败 会抛出异常ClassCaseException
    8.6 总结
        多态意味着 不同的形式。在面向对象的程序设计中，我们持有从基类继承而来的相同接口，以及使用该接口的不同形式，不同版本的动态绑定方法

第九章 接口
    接口和内部类为我们提供了一种将接口与实现分离的更加结构化的方法
    9.1 抽象类和抽象方法
        abstract void f(); 抽象方法， 只有声明，没有实现
        包含这种方法的类 叫做抽象类  absttract class
    9.2 接口
        interface关键字 定义接口
        一个接口表示： 所有实现了该特定接口的类看起来都像这样
        类要实现接口 需要使用关键字 implemens
        接口里的方法都是public 默认如此
    9.3 完全解耦
    9.4 java中的多重继承
        接口可以使用 多重继承，就好比一个类实现多个接口，就要实现多个接口里的方法
    9.5 通过继承来扩展接口
        通过继承，可以很容易地在接口中添加新的方法声明，还可以通过继承在新接口中组合数个接口。这两种情况都可以获得新的接口
        9.5.1 组合接口时的名字冲突
            要注意这种情况
    9.6 适配接口
    9.7 接口中的域
        接口里的函数和常量都是 static final 形式的 可以用他来定义常量
        9.7.1 初始化接口中的域
    9.8 嵌套接口
        在类中 嵌套接口 在类中在实现它，感觉使用并不高，只是一种支持写法
    9.9 接口与工厂
        接口尝尝用来实现工厂模式
    9.10 总结
        确定接口是理想乡选择，因而应该总是选择接口而不是具体的类

第十章 内部类
    可以将一个类的定义放在另一个类的定义内部，这就是内部类
    10.1 创建内部类
        普通内部类， 静态内部类， 匿名内部类 局部内部类
    10.2 链接到外部类
        将内部类的对象作为一个引用发到外部类中
    10.3 使用.this与.new
    10.4 内部类与向上转型
    10.5 在方法和作用域内的内部类
        要解决一个复杂的问题，又不希望外部可以访问这些类的定义，可以使用内部类来组合使用
    10.6 匿名内部类
        匿名内部类没有构造器
        10.6.1 在访工厂方法
            使用内部类实现工厂类
    10.7 嵌套类
        如果不需要内部类对象与其外围类对象之间有联系，那么可以将内部类声明为static。这通常为嵌套类
        10.7.1 接口内部的类
            可以用内部类 来写测试接口 就很隔离
        10.7.2 从多层嵌套类中访问外部类的成员
            内部类中可以调外部类的属性 尽管他是private的
    10.8 为什么需要内部类
        每个内部类都能独立地继承自一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响。
        内部类可以有多个实例，每个实例都有自己的状态信息，并且与其外围类对象的信息相互独立
        在单个外围类中，可以让多个内部类以不同的方式实现同一个接口，或继承同一个类
        创建内部类对象的时刻并不依赖于外围类对对象的创建。
        内部类并没有令人迷惑的is-a关系，它就是一个独立的实体
        10.8.1 闭包与回调
            闭包（closure）是一个可调用的对象，它记录了一些信息，这些信息来自于创建它的作用域，通过这个定义，可以看出内部类是面向对象的闭包，因为它不仅包含外围类对象的信息，还自动拥有一个指向此外围类对象的引用，在此作用域内，内部类有权操作所有的成员，包括private程璇
        10.8.2 内部类与控制框架
            多个控制框架（control framework）
            用用程序框架（application framework） 模板设计模式
            事件驱动系统  经典例子：图形用户接口GUI
    10.9 内部类的继承
        内部类的构造方法会相对复杂化，必须使用sper这种方式才可以通过
    10.10 内部类可以被覆盖么
        当继承了某个外围类的时候，内部类没有发生神奇的变化，这两个内部类是完全独立的实体，各自在自己的命名空间内
    10.11 局部内部类
        在方法里创建内部类，就属于局部内部类
        为什么要用局部内部类而不用匿名内部类呢？唯一的理由是 我们需要一个已命名的构造器，或者需要重载构造器
    10.12 内部类的标识符
        每个类编译后都会有 名字.class 文件 而内部类则是 名字$内部类.class 这种表示
    10.13 总结

第十一章 持有对象
    如果一个程序只包含固定数量的且其生命期都是已知的对象，那么这是一个非常简单的程序
    利用java的容器来持有对象，这一章主要讲java常见的容器内容
    11.1 泛型和类型安全的容器
        @SuppressWaringings 不受检查的异常
        ArrayList 默认存的对象是Object 如果不指定泛型，那么在get的时候 就会发送ClassCaseEExcetpion 类型转换的异常
        所以在使用容器时最好指定他存储的容器类型
    11.2 基本概念
        java的容器类库拥有两个不同的概念
        1. Collection 保存一组元素序列 list是 顺序保存元素 set 是不能有重复元素 queue 排队规则确定对象顺序
        2. Map 保存 key-vale 键值对的数据 也被称为字典 可以使用键来查找数据
    11.3 添加一组元素
        常用的工具方法 Arrays Collections
        使用 Collections.addAll()  Arrays.asList()
    11.4 容器的打印
        常见容器
        ArrayList ,LinkedList, HashSet, TreeSet, LinkedHashSet, HashMap, TreeMap, LinkedHashMap
        ArrayList,LinkedList 都是按照插入顺序保存元素，区别只是他们操作类型的性能上的区别
        HashSet LinkedHashSet TreeSet 都是保存一份数据，HaseSet 插入和提取都很快， LinkedHashSet 是保证插入顺序 TreeSet 则是比较 值 来排序保存数据默认升序
        HashMap 提供了快速查找数据 ，TreemAP 则保证类排序顺序 linkedHashMap 则按照插入顺序保存 同时保留了HashMap的查询速度
    11.5 List
        ArrayList 善于随机访问元素，但是中间插入和移除元素会很慢
        LinkedList 上虞插入和删除操作，提供了优化的顺序访问，随机访问则相对比较慢
        subList 截取中间的一部分 retainAll 交集操作， removenAll 移除部分元素 通过equals 判定， addAll 则是添加元素 可以是中间也可以是尾部
        isEmpty 是否为空 clear 清空容器 toArray 则是转换成数组
    11.6 迭代器
        迭代器是一种设计模式，它的工作是遍历并选择序列中的对象，而客户端不必知道或关系该序列的底层结构
        此外迭代器通常被称为轻量级对象， 创建它代价小
        比如java 的 Iterator 只能单向移动，
        1. 使用方法iterator()要求容器返回一个Iterator，Iterator将准备好返回序列第一个元素
        2. 使用next()获得序列中的下一个元素
        3. 使用hasNext() 检查序列中是否还有元素
        4. 使用remove()将迭代器新进返回的元素删除

        11.6.1 ListIterator
            是一个更加强大的Iterator的子类型，支持双向移动，可以使用set()方法替换它访问过的最后一个元素
            可以使用 ListIterator() 产生一个指向List开始处的ListIterator，也可以使用ListIterator方法创建一个指向列表索引为n的元素
    11.7 LinkedList
        执行在List中间插入和移除 要比ArrayList更高效，但是在随机访问上却要逊色一些
        LinkeList 还添加了可以使其用作 栈，队列 ，双端队列的方法
        getFirst() element() 如果List为空 则抛出异常NoSuchElementException peek 则会返回null
        removeFirst() remove() 同样数据为空 跑异常 而 poll() 则返回null
        addFirst add() addLast() 相同
        removeLast() 移除并返回列表的最后一个元素

    11.8 Stack
        栈 后进先出(LIFO) 容器，也被称为叠加栈， 最后一个压入的数据会第一个弹出，LinkList满足栈的特性，所以可以当做栈使用
        push 压栈 peek 战顶数据 pop 出站 isEmpty 是否为空
        可以使用 net.mindivew.util.Stack

    11.9 Set
        不保存重复的元素，通过一定的判定条件，为了看set 里面是否重复，set拥有 hashset 快速查找元素的功能
        HashSet使用了三列，TrreeSet存储使用了红-黑树，保证了值的排序， LinkeHashList，使用了链表维护了元素的插入顺序
    11.10 Map
        根据 key-value 来存储的数据 每个key 不可以相同
        keySet() 可以获取所有的key 的set 集合

    11.11 Queue
        队列 先进先出 （FIFO） LinkList 天然支持 队列功能
        offer() 方法将一个元素插入对尾
        peek() element() 都是不移除队首元素 展示对首数据 一个抛异常 一个返回null
        poll() remove() 都是移除并且展示队首数据 一个抛异常 一个返回 null

        11.11.1 PriorityQueue
            优先级队列，声明下一个弹出的元素是最优先级的数据
            offer() 插入数据会进行排序

    11.12 Collection 和 Iterator
        Collection 是所有序列容器的共性跟接口
        Iterator 是Collection 的父接口 用于迭代器的使用

    11.13 Foreach与迭代器
        foreach语法主要用于数组
        iterator() 返回了Iterator<String> 的实例，可以使用 foreach语句中
        大部分类都是Iterable类型
        而数组不可以当成Iterable参数传递

        11.13.1 适配器方法惯用法

    11.14 总结

第十二章 通过异常处理错误
    java 的基本理念： 结构不佳的代码不能运行
    12.1 概念
    12.2 基本异常
        异常情形(exceptional condition) 当异常出现时 程序停止 向外部抛出一个异常
        程序会寻找一个恰当地方来继续执行程序，这个恰当的地方就是 异常处理程序
        12.2.1 异常参数
            出现异常时，我们回在堆上 new 异常对象
            所有标准异常会有两个构造器，一个是默认构造器 ，一个是接受字符串作为参数，把相关信息放入到异常中
            关键字 throw
    12.3 捕获异常
        首先要拥有 监控区域(guarded region)，它是一段可能产生异常的代码，并且后面跟着处理这些异常的代码
        12.3.1 try块
            try {} 监控区域
        12.3.2 异常处理程序
            catch (Type type) {} 处理程序
            终止和恢复
            当异常出现时 ，一般两种解决方案，如果这个异常已经导致后续的程序无法处理，则终止这个程序，如果这个异常后续还可以处理，可以使用
            while(){try{}} 这种方式 ，来忽略这次异常 恢复的执行任务
    12.4 创建自定义异常
        可以定义一个类 继承Exception 来构造自己的异常
        12.4.1 异常与记录日志
            使用Logger 来控制出现的异常输出
    12.5 异常说明
        使用 throws 来标志这个会出现什么异常，让使用者进行处理
    12.6 捕获所有异常
        可以使用捕获 Exception 来捕获所有异常
        12.6.1 栈轨迹
            printStackTrace()
        12.6.2 重新抛出异常
            在 catch 在throw 出异常
            使用 fillInstackTrace() 变成了异常的新发生地
        12.6.3 异常连
            常常会想要在捕获一个异常后抛出另一个异常，并且希望把原始异常信息保存下来，这就是异常链
            Throwable是 异常顶级父类， 下面有三种异常，Error（java虚拟机报告系统错误）
            Excetpion  RuntimeException
            可以使用initCause() 方法而不是构造器 异常链接起来
    12.7 java 标准异常
        Throwable这个java 类被 用来表示任何可以作为异常被抛出的类
        Error 用来表示编译时和系统错误
        Exception 是可以被抛出基本类型
        12.7.1 特例 RuntimeException
            只能在代码中忽略RuntimeException（及其子类）类型的异常，其他类型异常的处理都是由编译器强制实时的，原因是 RuntimeException代表的是编程错误
            1. 无法预料的错误，比如你控制方为之外传递进来的null 引用
            2. 作为程序员，应该在代码中进行检查的错误
    12.8 使用finally 进行清理
        对于一些代码，可能会希望无论try 中的异常是否被抛出，都要执行这部分代码，就可以放入finally中执行
        12.8.1 finally用来做什么
            用来关掉 已经打开的文件或网络连接，屏幕上画的图形，甚至外部世界的某个开关
        12.8.2 在return中使用finally
            有return finally也会返回
        12.8.3 缺憾： 异常丢失
            异常作为程序出错的标志，决不应该被忽略，但它还是有可能被轻易的忽略，用特殊方式使用finally子句
    12.9 异常的限制
        当覆盖方法的时候，只能抛出基类方法的异常
    12.10 构造器
        在构造对象时抛出异常
    12.11 异常匹配
        抛出异常的时候，异常处理系统会按照代码的书写顺序找出“最近”的处理程序。找到匹配的处理程序之后，它就认为异常将得到处理，然后就不再继续查找了
        查找的时候并不要抛出的异常同处理程序所声明的异常完全匹配。派生类的对象也可以匹配其基类的处理程序。
    12.12 其他可选方式
        异常处理系统就像一个活门（trap door）,就是代表主程序无法正常执行，通过活门进入指定工作内容
        12.12.1 历史
        12.12.2 观点
        12.12.3 把异常传递给控制台
        12.12.4 把 被检查的异常 转换为 不检查异常
    12.13 异常使用指南
        应该在下列情况下使用异常；
        1. 在恰当的级别处理问题（在知道该如何处理的情况下才捕获异常）
        2. 解决问题并且重新调用产生异常的方法
        3. 进行少许修补，然后绕过异常发生的地方继续执行。
        4. 用别的数据进行计算，以代替方法预计会返回的值
        5. 把当前运行环境下能做的事情尽量做完，然后把相同的异常重抛到更高层
        6. 把当前运行环境下能做的事情尽量做完，然后把不同的异常抛到更高层。
        7. 终止程序。
        8. 进行简化（如果你的 异常模式问题变得太复杂，那用起来会非常痛苦也很烦人）
        9. 让类库和程序更安全（这既是在为调试做短期投资，也是在为程序的健壮性做长期投资）
    12.14 总结

第十三章 字符串
    可以证明， 字符串操作是计算机程序设计中最常见的行为。
    13.1 不可变String
        final 修饰，每次获取的都是新的String
    13.2 重载 + 与StringBuilder
        String 对象是不可变的，你可以给一个String 对象加任意多的别名。因为String对象具有只读特性，所以他的任何引用都不可能改变他的值
        编译器会帮你优化一部分 String 的拼接性能
    13.3 无意识的递归
        toString() 方法，会打印出对象的信息，如果想打印地址，可以使用this 这个方式
    13.4 String上的操作
        方法      参数，重载版本     应用
        构造器     重载笨笨，默认版本   创建String对象
        length()                    String中字符的个数
        charAt()    Int索引          取得String中该索引位置上的char
        getChars(),getBytes 要复制部分的起点和重点的索引，复制的目标数组，目标数组的起始索引    复制char或byte到一个目标数组中
        toCharArray()                   生成一个char[],包含String的所有字符
        equals(),equalsIgnoreCase() 与之进行比较的String   比较两个String的内容是否相同
        compareTo() 与之进行比较的String   按词典顺序比较String的内容，比较结果为负数，零或正数。注意，大小写并不等价
        contains()  要搜索的CharSequence    如果该String对象包含参数的内容，则返回true
        contentEquals() 与之进行比较的CharSequence或StringBuffer    如果该String与参数的内容完全一致，则返回true
        equalsIgnoreCase()  与之进行比较的String   忽略大小写，如果两个String的内容相同，则返回true
        reglonMatcher()     该String的索引偏移量，另一个String及其索引偏移量，要比较的长度。重载版本增加了忽略大小写功能    返回boolean结果，以表名所比较区域是否相等
        startsWith()        可能的起始String。重载版本在参数中增加了偏移量      返回boolean结果，以表名改String是否以参数起始
        endsWith()          该String可能的后缀String      返回boolean，以表名此参数是否该字符串的后缀
        indexOf(),lastIndexOf()     重载版本包括：char，char与起始索引，String，String与起始索引        如果该String并不包含此参数，就返回-1，否则返回此参数在String中的起始索引，lastIndexOf（）是从后向前搜索
        substring()(subSequence())  重载版本，起始索引，起始索引+重点坐标     返回一个新的string，以包含参数指定的子字符串
        concat()        要链接的String      返回一个新的String对象，内容为原始String链接上参数String
        replace()       要替换掉的字符串，用来进行替换的新字符     返回替换字符后的新String对象，如果没有替换发生，则返回原始的String对象
        toLowerCase() toUpperCase()                 将字符的大小写改变后，返回一个新String对象。如果没有改变发生，则返回原始的String对象
        trim()                                      将String连贯的空白字符删除后，返回一个新的String对象。如果没有改变发生，则返回原始的String对象
        valueOf()       从在版本        返回一个表示参数内容的String
        intern()                        为每个唯一的字符序列生成一个且仅生成一个String引用
    13.5 格式化输出
        13.5.1 printf()
            printf("Row 1: [%d %f]", x, y)
        13.5.2 System.out.format()
        13.5.3 Formatter类
        13.5.4 格式化说明符
        13.5.5 Formatter转换
            d 整数（十进制）
            c Unicode字符
            b boolea值
            s String
            f 浮点数（十进制）
            e 浮点数（科学技术）
            x 整数（十六进制）
            h 散列码（十六进制）
            % 字符"%"
        13.5.6 String.format()
    13.6 正则表达式
        13.6.1 基础
        13.6.2 创建正则表达式
            Pattern 正则表达式类
            . 任意字符 [abc] 包含abc任意字符 [^abc]除了abc之前的任意字符 [a-zA-Z]范围从a到z或者从A到Z
            [abc[hij]] 任意a b c hi j 字符
            [a-z&&[h(j)]] 任意h i 或 j   \s 空白符  \S 非空白符 \d 数字 \D 非数字 \w词字符 \W 非词字符
            ^ 一行开的起始    $ 一行的结束  \b 词的边界  \B非词的边界  \G前一个匹配的结束
        13.6.3 量词
            贪婪型： 量词总是贪婪的，除非有其他的选项被设置。贪婪表达式会为所有可能的模式发现尽可能多的匹配。
            勉强性： 用问号来指定，这个量词匹配满足模式所需的最少字符数，因此也称作懒惰的，最少匹配的
            占有行： 目前，这种类型的量词只有java语言中才可用
        13.6.4 Pattern和Matcher
            用 static Pattern.comlile()方法边界表达式
            用 matcher()方法 返回Matcher对象
            macthcer 拥有 group的概念
            Pattern 标记
        13.6.5 split()
        13.6.6 替换操作
        13.6.7 reset
            通过reset()方法，可以将现有的Matcher对象应用于一个新的字符序列
        13.6.8 正则表达式与Java I/O
    13.7 扫描输入
        Scanner的构造器接受任何类型的输入对象
        13.7.1 Scanner定界符
            默认是用空白字符对输入进行分词，可以使用正则表达式来分词
        13.7.2 用正则表达式扫描
    13.8 string Tokenizer
    13.9 总结

第十四章 类型信息
    运行时类型信息使得你可以在程序运行时发现和使用类型信息
    java是如何让我们在运行时识别对象和类的信息，主要两种方式，一种是传统的RTTI，它嘉定我们在编译时知道了所有类型
    另一种是反射机制，它允许我们在运行时发现和使用类的信息
    14.1 为什么需要RTTI （Run-Time Type Identification）
        使用RTTI，可以查询某个类引用所只想的对象的确切类型，然后进一步进行操作
    14.2 class 对象
        class 对象就是用来创建类的所有的常规对象，java使用class对象来执行其RTTI，即使你正在执行的是类似转型这样的操作。class类还拥有大量的使用RTTI的其他方式
        jvm 会根据当前的情况 利用类加载器，将指定的类加载jvm的内存中，如果这个类在就获得class的类对象，如果没加载进来，则会查找.class的文件，进行验证，然后加载到内存中
        使用 Class.forName("com.dd...Student") 查找类名的类
        getSimpleName() getCanonicalName()
        printInfo()  getName()
        getInterfaces() 返回Classd对象
        getSuperclass() 直接基类
        14.2.1 类字面常量
            java还提供了另一种方法来生成对Class对象的引用，即使用磊子面常量 莱斯 List.class
            注意： 当时用.class 来创建对class对象的引用时，不会自动地初始化该class对象。为了使用类而做的准备工作实际包含三个步骤
            1. 加载 类加载器执行
            2. 链接 在链接阶段验证类中的字节码， 为静态域分配存储空间，如果可以，会创建对其他类的所有引用
            3. 初始化。 如果该类是超类，则对齐初始化，执行青苔初始化器和静态初始化快
        14.2.2 泛化的class引用
            class 引用总是指向某个class对象
            使用泛型来构建 class，可以使用通配符 来详细指定class的类型 通配符?
            Class<?> intClass = int.class
            intClass = double.class
            cast 可以转换具体的类型

    14.3 类型转换前先做检查
        我们已知的RTTI形式包括
        1. 传统的类型转换
        2. 代表对象的类型的class对象
        使用 instanceof 判定类型是否是对应类型
        instancof 有严格的限制， 只可将其与命名类型进行比较，而不能与class对象作为比较
        14.3.1 使用类字面常量
        14.3.2 动态的instanceof
            Class.isInstance()
        14.3.3 递归计数
            isAssignableFrom() 运行时检查，校验传递的对象是否属于我们的继承结构
    14.4 注册工厂
    14.5 instanceof 与class的等价性
        instanceof 保持了类型的概念，而用== 比较实际的对象，没有考虑继承，只考虑是否是这个类型
    14.6 反射：运行时的类信息
        14.6.1 类方法提取器
            反射支持其他特性，例如序列化和JavaBean,
            使用方法
            Class<?> c = Class.forName();
            c.getMehods(); c.getConstructors()
    14.7 动态代理
        代理是基本的设计模式之一，它是你为了提供额外的或不同的操作，而插入的用来代替实际对象，这些操作通常设计实际对象的通信，因此代理通常充当着中间人的角色
        通过 Proxy.newProxyInstance()
        invoke() 方法传递代理对象和参数，进行代理执行
        更多代理方式可以 看我的代理详解篇章
    14.8 空对象
        可以当做临时赋值，交给变量，防止编译报错
        14.8.1 模拟对象与桩
            空对象的逻辑变体是模拟对象和桩。与空对象一样，它们都表示在最终的程序中所使用的“实际”对象，但是，模拟对象和桩都只是假扮可以传递实际信息的存活对象，而不是像空对象那样可以称为null的一种更加智能化的替代物
    14.9 接口与类型信息
        interface关键字的一种重要目标就是允许程序员隔离构件，进而降低耦合性。如果你编写接口，那么久可以实现这一目标，但是通过类型信息，这种耦合性还是会传播出去---接口并非是对解耦的一种无懈可击的保障
    14.10 总结

第十五章 泛型
    一般的类和方法，只能使用具体的类型：要么是基本类型，要么是自定义的类，如果要编写可以用多种类型的代码，这种刻板的限制对代码的束缚就会很大
    15.1 与C++的比较
    15.2 简单泛型
        许多原因需要有泛型，而使用最高的就是 容器类
        核心概念：告诉编译器想使用什么类型，然后编译器帮你处理一切细节
        15.2.1 一个元祖类库
        15.2.2 一个堆栈类
            末端哨兵 用来标志是否容器为空
        15.2.3 RandomList
    15.3 泛型接口
        泛型可以应用于接口。例如 生成器（generator），这是一种专门负责创建对象的类
    15.4 泛型方法
        public <T>void getT(T t)
        使用泛型方法时，不需要指明参数类型，编译器为什么找出具体类型，称为类型参数的推断(type argument inference)
        15.4.1 杠杆利用类型参数推断
            显示的类型说明
            在泛型方法中，可以显式滴指明类型
        15.4.2 可变参数与泛型方法
        15.4.3 用于Generator的泛型方法
        15.4.4 一个通用的Generator
        15.4.5 简化元祖的使用
        15.4.6 一个Set实用工具
    15.5 匿名内部类
    15.6 构造复杂的模型
    15.7 擦除的神秘之处
        在泛型代码内部，无法获得任何有关泛型参数类型的信息
        java泛型是使用擦除来实现的，这意味着当你在使用泛型，任何具体的类型信息都被擦出了，你唯一知道的就是你在使用一个对象。因此List<String>和List<Integer>在运行时
            事实上是相同的类型。这两种形式都被擦除成他们的 原生类型，即List
        15.7.1 C++ 方式
            使用 extends Object 方式来定位擦除 就可以安全的调用 f() 方法
            我们说泛型类型参数将擦除到它的第一个边界，我们还提到了类型参数的擦除。编译器实际上会把类型参数替换为它的擦除
        15.7.2 迁移兼容性
        15.7.3 擦除的问题
            泛型不能用于显式地引用运行时类型的操作中，例如转型 instanceof操作和new的表达式
        15.7.4 边界处的动作
    15.8 擦除的补偿
        15.8.1 创建类型实例
            使用工厂类来构建 无法new T() 的问题
        15.8.2 泛型数组
            T[]
    15.9 边界
        上边界 是用 extends Object
        下边界 ? super MyClass
    15.10 通配符
        ? extends Fruit 具有任何从Fruit继承的类型列表
        T extends A & B 一种写法 并不是很了解
        15.10.1 编译器有多聪明
        15.10.2 逆变
            超类通配符 ? super MyClass
        15.10.3 无解通配符
            <?> 任何事物
        15.10.4 捕获转换
    15.11 问题
        15.11.1 任何基本类型都不能作为类型参数
            可以使用包装类 来替代 基本类型
            但是，自动包装机制不能应用于数组，因此这无法工作
        15.11.2 实现参数化接口
            一个类不能实现同一个泛型接口的两种变体，由于擦除的原因，这两个变体会成为相同的接口。
        15.11.3 转型和警告
            使用带有泛型类型参数的转型或instanceof不会有任何效果
        15.11.4 重载
            由于擦除的原因，重载方法将产生相同的类型签名
            由此不同的是，当被擦除的参数不能产生唯一的参数列表时，必须提供明显有区别的方法名
        15.11.5 基类劫持了接口
    15.12 自限定的类型
        class SelfBounded<T extends SelfBounded<T>>{//
        这种很难解析的写法
        15.12.1 古怪的循环泛型
        15.12.2 自限定
            BasicHolder可以使用任何类型作为其泛型参数
            自限定所作的，就是要求在继承关系中，像下面这样使用这个类
            class A extends SelfBounded<A>{}
            自限定限制只能强制作用域继承关系！
        15.12.3 参数协变
            自限定类型的价值在于它们可以产生协变参数类型--- 方法参数类型会随子类而变化。
    15.13 动态类型安全
        java.util.Collections中有一组便利工具，解决类型检查问题，它们是checkedCollection(),checkedList(),checkedMap(),checkedSet(),checkedSortedMap()和checkedSortedSet()
    15.14 异常
        由于擦除的原因，将泛型应用于异常是非常受限的。catch语句不能捕获泛型的异常，因为在编译器和运行时都必须知道异常的确切类型。泛型类也不能直接活间接继承自Throwable
    15.15 混型
        术语混型随时间的推移好像拥有了无数的含义，但是其最基本的概念是混合多个类的能力，以产生一个可以表示混型中所有类型的类。这往往是你最后的手段，它将使组装多个类变得简单易行
        混型的价值之一是它们可以将特性和行为一致地应用于多个类上。如果想在混型类中修改某些东西，作为一种意外的好处，这些修改将会应用于混型所应用的所有类型之上。正由于此，混型有一点面向方面编程AOP的味道，而方面经常被建议用来解决混型问题
        15.15.1 C++中的混型
        15.15.2 与接口混合
        15.15.3 使用装饰器模式
            装饰器模式使用分层对象来动态透明地向单个对象中添加责任。
        15.15.4 与动态代理混合
    15.16 潜在类型机制
        鸭子类型机制：它走起来像鸭子，并且叫起来也像鸭子，那么你就可以将它当做鸭子对待
    15.17 对缺乏潜在类型机制的补偿
        java 不支持潜在类型机制，可以用一些别的方式来补偿这些
        15.17.1 反射
        15.17.2 将一个方法应用于序列
        15.17.3 当你并未碰巧拥有正确的接口时
        15.17.4 用适配器仿真潜在类型机制
    15.18 将函数对象用作策略
        策略设计模式，这种设计模式可以产生更优雅的代码，因为它将 变化的事物 完全隔离到了一个函数对象中
    15.19 总结 转型真的如此之槽么

第十六章 数组
    16.1 数组为什么特殊
        数组与其他种类的容器之间之间的区别三方面：效率，类型和保存基本类型的能力
    16.2 数组是第一级对象
        无论使用哪种类型的数组，数组标识符其实只是一个引用，只想在堆中创建的一个真实对象，这个对象用以保存指向其他对象的引用。
    16.3 返回一个数组
        String[] rand = {"aa","b"}
    16.4 多维数组
        int[][] a = {{1,2,3},{4,5,6}}
    16.5 数组与泛型
    16.6 创建测试数据
        16.6.1 Arrays.fill() 填充
        16.6.2 数据生成器
        16.6.3 从Generatory 中创建数组
    16.7 Arrays实用功能
        equals() 判断两个数组是否相等
        deepEquals 用于多位数组
        fill() 填充
        sort 排序
        binarySearch 用于已经排序的数组查找元素
        toString() 产生数组的String表示
        hashCode 散列码
        asList 撰文List容器
        16.7.1 复制数组
            System.arraycopy() 需要的参数 原数组 ，开始复制的偏移量 目标数组偏移量 复制元素的个数
        16.7.2 数组的比较 equals
        16.7.3 数组元素的比较
            使用Comparable.compareTo 方法进行比较
            构建单独的类 实现 Comparator接口 重写 compare方法 和equals 方法 后面不是必须
        16.7.4 数组的排序
            java内置的算法为 快速排序  ，以及针对对象设计的稳定归并排序
        16.7.5 在已排序的数组中查找 Arrays.binarySearch()
    16.8 总结

第十七章 容器深入研究
    17.1 完整的容器分类法
        看图 <JAVA编程思想_容器高级分类>
        java se5 增加了
        Queue 接口 以及实现PriorityQueue和各种风格的Blockingueue
        ConcurrentMap 实现了ConcurrentHashMap，他们也是用于多线程机制
        CopyOnWriteArrayList和CopyOnWriteArraySet，他们也是用于多线程机制的
        EnumSet和EnumMap，为使enum而设计的Set和Map的特殊实现，
        在Collections类中的多个便利方法
    17.2 填充容器
        可以使用Collections fill() 方法
        17.2.1 一种Generator解决方案
            LinkedHashSet 维护了插入顺序的链接列表
        17.2.2 Map生成器
        17.2.3 使用Abstract类
            享元模式，使得对象的一部分可以被具体化
    17.3 Collection的功能方法
        boolean add(T)
        确保容器持有具有泛型类型T的参数，如果没有将此参数添加进容器，则返回false
        boolean addAll(Collection<? extends T>)
        添加参数中的所有元素。只添加了任意元素就返回true
        vold clear()
        移除容器中所有元素
        boolean contains(T)
        如果容器已经持有具有泛型类型T此参数，则返回true
        boolean containsAll(Collection<?>)
        如果容器持有此参数中的所有元素，则返回true
        boolean isEmpty()
        容器中没有元素时返回true
        Iterator<T> iterator()
        返回一个Iterator<T>, 可以用来便利容器中的元素
        Boolean remove<Object>
        如果参数在容器中，则移除此元素的一个实例，如果做了移除动作，则返回true
        boolean removeAll(Collection<?>)
        移除参数中的所有元素。只有移除动作发生就返回true(可选的)
        Boolean retainAll(Collection<?>)
        只保存参数中的元素（交集的概念），只要Collection发生了改变就返回true
        int size()
        返回容器中元素的数目
        Object[] toArray()
        返回一个数组，该数组包含容器中的所有元素
        <T> T[] toArray(T[] a)
        返回一个数组，该数组包含容器中的所有元素。返回结果的运行时类型与参数数组a的类型相同，而不是单纯的Object
    17.4 可选操作
       17.4.1 未获支持的操作 UnsupportedOperationException
            Arrays.asList() 出来的list 就无法在添加元素了
    17.5 List的功能方法
        add, addAll,contains,containsAll,get,indexOf,isEmpty,iterator,listIterator,lastIndexOf,retainAll,removeAll
        set,
        ArrayList, LinkedList
    17.6 Set存储顺序
        Set
        存入Set的每个元素都必须是唯一的，因为Set不保存重复元素，加入Set的元素必须定义equals()方法以确保对象的唯一性。Set与Collection有安全一样的接口。
        Set接口不保证维护元素的次序
        HashSet
            为快速查找而设计的Set。存入HashSet的元素必须定义HashCode()
        TreeSet
            保持次序的Set，底层为树结构。使用它可以从Set中提取有序的序列。元素必须实现Comparable接口
            TreeSet<Integer> treeSet = new TreeSet<>((o1, o2) -> o1 - o2);
        LinkedHashSet
            具有HashSet的查询速度，且内部使用链表维护元素的顺序（插入的次序）。于是在使用迭代器便利Set时，结果会按照元素插入的次序现实，元素也必须定义HashCode方法
        17.6.1 SortedSet
            first，last, subSet(fromElement,ToElement), headSet(toElement),tailSet(fromElement)
    17.7 队列
        LinkedList,PriorityQueue
        17.7.1 优先级队列
            需要实现Comparable来进行控制
        17.7.2 双向队列
            LinkedList 实现了双向队列的功能
            addFirst addLast,getFirst,getLast,removeFirst,removeLast,size,toString
    17.8 理解Map
        HashMap, TreeMap, LinkedHashMap, WeekHashMap, ConcurrentHashMap, IdentityHashMap
        17.8.1 性能
            性能是映射表中的一个重要问题，get()线性搜索时，执行速度会相当地慢，而正式HashMapt提高速度的地方，使用了特殊的值，散列码，来取代对键的缓慢搜索
            HashMap 是是使用了对象的hashCode() 进行快速查询，显著提高了性能
            HashMap
            Map基于散列表实现，插入和查询“键值对”的开销是固定的，可以通过构造器设置容量和负载因子，以调整容器的性能
            LinkedHashMap
            类似于HashMap，但是迭代遍历时，取得 键值对 的顺序是插入的次序，或者是最近最少使用LRU的次序，只比HashMap慢一点，而在迭代访问时，方为更快，因为它使用链表维护内部次序
            TreeMap
            基于红黑树实现。查看键 或键值对时，它们会被排序，TreeMap的忒点在于，所得到的的结果是警告排序的。TreeMap是唯一带有subMap方法的map，它可以返回一个子树
            WeekHashMap
            弱键 映射，允许释放映射所指向的对象；这是为解决某类特殊问题而设计的。如果映射之外没有引用指向某个键，则此键可以被垃圾收集器回收
            ConcurrentHashMap
            一种线程安全的Map，它不涉及同步加锁
            IdentityHashMap
            使用 == 代替equals()对 键进行比较的三列映射。专为解决特殊问题而设计的










